---
phase: 15-init-onboarding-polish
plan: 03
type: execute
wave: 2
depends_on:
  - "15-01"
  - "15-02"
files_modified:
  - packages/cli/src/components/Onboarding.tsx
  - packages/cli/src/commands/init.ts
autonomous: true
requirements:
  - ONBOARD-TELEGRAM
  - ONBOARD-HATCH
  - ONBOARD-STREAM

must_haves:
  truths:
    - "User can enter Telegram bot token during tek init and it is stored in keychain"
    - "User can select a personality preset or defer to conversational setup during tek init"
    - "User can name their agent and set display name during Hatch step"
    - "Skipping Hatch creates BOOTSTRAP.md for deferred conversational setup"
    - "Total onboarding steps remain manageable (under 12 user-facing screens)"
    - "Telegram step is skippable"
  artifacts:
    - path: "packages/cli/src/components/Onboarding.tsx"
      provides: "Telegram and Hatch wizard steps integrated into onboarding flow"
      contains: "telegram-ask"
    - path: "packages/cli/src/commands/init.ts"
      provides: "init handler saves agentName, userDisplayName, stores Telegram token in keychain, creates BOOTSTRAP.md"
      contains: "agentName"
  key_links:
    - from: "packages/cli/src/commands/init.ts"
      to: "packages/db/src/memory/ensure-memory.ts"
      via: "ensureMemoryFile call for BOOTSTRAP.md"
      pattern: "ensureMemoryFile.*BOOTSTRAP"
    - from: "packages/cli/src/commands/init.ts"
      to: "packages/cli/src/vault/index.ts"
      via: "addKey for telegram token"
      pattern: "addKey.*telegram"
    - from: "packages/cli/src/components/Onboarding.tsx"
      to: "packages/core/src/config/schema.ts"
      via: "OnboardingResult with agentName and personalityPreset"
      pattern: "agentName"
---

<objective>
Add Telegram bot token and personality Hatch steps to the onboarding wizard, and wire the init command to persist all new data.

Purpose: Users should be able to configure Telegram and personality during `tek init` instead of manually. This completes the Phase 15 onboarding polish goal.
Output: Full onboarding wizard with Telegram + Hatch steps, init.ts saving all new config fields.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-init-onboarding-polish/15-01-SUMMARY.md
@.planning/phases/15-init-onboarding-polish/15-02-SUMMARY.md
@packages/cli/src/components/Onboarding.tsx
@packages/cli/src/commands/init.ts
@packages/db/src/memory/ensure-memory.ts
@packages/db/memory-files/BOOTSTRAP.md
@.planning/phases/15-init-onboarding-polish/15-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Telegram and Hatch steps to Onboarding wizard</name>
  <files>packages/cli/src/components/Onboarding.tsx</files>
  <action>
1. Add new steps to the OnboardingStep union type:
   - `"telegram-ask"` — Ask if user wants to set up Telegram
   - `"telegram-input"` — TextInput for bot token
   - `"hatch-ask"` — Personality preset selection
   - `"hatch-name"` — Agent name + user display name inputs

2. Add new state variables:
   ```typescript
   const [telegramToken, setTelegramToken] = useState("");
   const [personalityPreset, setPersonalityPreset] = useState<string>("");
   const [agentName, setAgentName] = useState(existingConfig?.agentName ?? "");
   const [userDisplayName, setUserDisplayName] = useState(existingConfig?.userDisplayName ?? "");
   ```

3. Update OnboardingResult interface to include new fields:
   ```typescript
   export interface OnboardingResult {
     securityMode: SecurityMode;
     workspaceDir?: string;
     keys: { provider: Provider; key: string }[];
     defaultModel?: string;
     modelAliases?: ModelAliasEntry[];
     telegramToken?: string;
     personalityPreset?: string;
     agentName?: string;
     userDisplayName?: string;
   }
   ```

4. Update OnboardingProps.existingConfig to include agentName and userDisplayName.

5. Update the step flow — after keys-more (or keys-ask skip), go to telegram-ask instead of model-select. The full flow becomes:
   ```
   welcome -> mode -> workspace -> keys-ask -> keys-provider -> keys-input ->
   keys-more -> telegram-ask -> [telegram-input] -> model-select ->
   model-alias-select -> [model-alias-name] -> hatch-ask -> [hatch-name] -> summary -> done
   ```

   This means: everywhere that currently transitions to "model-select" from the keys steps, change to "telegram-ask". Then telegram-ask/telegram-input transition to model-select.

6. Implement "telegram-ask" step:
   - Text: "Set up Telegram integration?"
   - Hint: "You'll need a bot token from @BotFather on Telegram."
   - ConfirmInput: onConfirm -> "telegram-input", onCancel -> proceed to model selection (use the same buildAvailableModels logic).

7. Implement "telegram-input" step:
   - Text: "Enter your Telegram bot token:"
   - Hint: "Get one from @BotFather: /newbot command, then copy the token."
   - TextInput with placeholder "123456789:ABCdefGHIjklMNOpqrsTUVwxyz"
   - onSubmit: if non-empty, setTelegramToken. Then proceed to model selection.

8. Update model-alias-select/model-alias-name — when done (going to summary), go to "hatch-ask" instead.

9. Implement "hatch-ask" step:
   - Text: "Personalize your agent?"
   - Use Select with 6 options:
     - "Professional — Concise, formal, business-appropriate" -> value "professional"
     - "Friendly — Conversational, warm, asks follow-ups" -> value "friendly"
     - "Technical — Detailed, code-heavy, precise" -> value "technical"
     - "Opinionated — Direct, has preferences, personality-forward" -> value "opinionated"
     - "Custom — Set up later via conversation" -> value "custom"
     - "Skip — Use default personality" -> value "skip"
   - onChange: if "skip", go to summary. If "custom", setPersonalityPreset("custom"), go to summary (BOOTSTRAP.md handles it). Otherwise, setPersonalityPreset(value), go to "hatch-name".

10. Implement "hatch-name" step:
    - Two sequential inputs (use a sub-step counter or a simple state flag):
    - First: "What should your agent be called?" TextInput, placeholder "e.g. Atlas, Sage, Tek". On submit, setAgentName, show second input.
    - Second: "What should the agent call you?" TextInput, placeholder "e.g. your name or a nickname". On submit, setUserDisplayName, go to summary.
    - Implementation: use a `hatchSubStep` state (0 = name, 1 = displayName). When hatchSubStep is 0, render agent name input. When 1, render user display name input. On second submit, go to summary.
    - Use key props on TextInputs to ensure clearing: `key={\`hatch-\${hatchSubStep}\`}`.

11. Update summary step to show:
    - Telegram: configured / not configured
    - Personality: preset name or "Custom (will set up on first chat)" or "Default"
    - Agent name (if set)

12. Update the onComplete call in summary to include new fields:
    ```typescript
    onComplete({
      securityMode: mode,
      workspaceDir: mode === "limited-control" ? workspaceDir : undefined,
      keys,
      defaultModel: defaultModel || undefined,
      modelAliases: modelAliases.length > 0 ? modelAliases : undefined,
      telegramToken: telegramToken || undefined,
      personalityPreset: personalityPreset || undefined,
      agentName: agentName || undefined,
      userDisplayName: userDisplayName || undefined,
    });
    ```

IMPORTANT for step count management (ONBOARD-STREAM): Telegram ask + input is 1-2 screens (conditional). Hatch ask + name is 1-2 screens (conditional). Total worst case: 12 screens. Most users will see 8-10 because telegram-input and hatch-name are conditional.
  </action>
  <verify>
    Run `cd /Users/hitekmedia/Documents/GitHub/tek && npx tsc --noEmit -p packages/cli/tsconfig.json` — must pass with zero errors.
  </verify>
  <done>
    Onboarding wizard has telegram-ask, telegram-input, hatch-ask, hatch-name steps. Flow transitions correctly. All new fields included in OnboardingResult. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire init.ts to persist Telegram token, personality, and BOOTSTRAP.md</name>
  <files>packages/cli/src/commands/init.ts</files>
  <action>
1. Import ensureMemoryFile from @tek/db:
   ```typescript
   import { recordAuditEvent, ensureMemoryFile } from "@tek/db";
   ```

2. Import copyFileSync, existsSync from "node:fs" and join, dirname, resolve from "node:path" and fileURLToPath from "node:url" (for preset file copying).

3. In the onComplete callback, after storing API keys but before saving config:

   a. Store Telegram token in keychain if provided:
   ```typescript
   if (result.telegramToken) {
     addKey("telegram" as any, result.telegramToken);
   }
   ```
   Note: "telegram" is now in the PROVIDERS tuple (from Plan 01), so the cast may not be needed if Provider type is inferred. Check — if Provider type now includes "telegram", use it directly: `addKey("telegram", result.telegramToken)`.

   b. Handle personality preset:
   - If result.personalityPreset === "custom" or result.personalityPreset is undefined/empty:
     - Call `ensureMemoryFile("BOOTSTRAP.md", "BOOTSTRAP.md")` to copy the bootstrap template to ~/.config/tek/memory/BOOTSTRAP.md (only if it doesn't already exist — ensureMemoryFile handles this).
   - If result.personalityPreset is a named preset (professional/friendly/technical/opinionated):
     - The preset file is at packages/db/memory-files/presets/{preset}.md
     - We need to copy it to the SOUL.md location. Use the TEMPLATE_DIR pattern from ensure-memory.ts. Actually, simpler: read the preset file content and write it to the SOUL.md path.
     - Import `readFileSync, writeFileSync` from "node:fs".
     - Resolve template dir: `const templateDir = resolve(dirname(fileURLToPath(import.meta.url)), "../../node_modules/@tek/db/memory-files");` — but this is fragile. Better approach: export a helper from @tek/db.
     - SIMPLEST approach: Add a new function to @tek/db's ensure-memory.ts: `applyPresetToSoul(presetName: string): void` that copies presets/{presetName}.md content over the SOUL.md file. But that modifies a Plan 01 file.
     - ALTERNATIVE: In init.ts, use the existing ensureMemoryFile to get the SOUL.md path, then use fs to read the preset and overwrite. The preset files are in the same template directory as BOOTSTRAP.md. We can add a small export from @tek/db: `getTemplatePath(filename: string): string`.
     - PRAGMATIC approach: Add an `applyPersonalityPreset(presetName: string)` export to @tek/db ensure-memory.ts that reads `presets/{presetName}.md` from the template dir and writes it to `CONFIG_DIR/memory/SOUL.md`. This function is a natural extension of the ensure-memory module.

   Actually, to keep Plan 01 files clean and this task self-contained, add the function here in init.ts as a local helper OR add it to @tek/db. Since @tek/db already owns memory-files and ensure-memory.ts, add it there.

   **Add to packages/db/src/memory/ensure-memory.ts:**
   ```typescript
   export function applyPersonalityPreset(presetName: string): boolean {
     const presetPath = join(TEMPLATE_DIR, "presets", `${presetName}.md`);
     if (!existsSync(presetPath)) return false;
     const soulPath = join(CONFIG_DIR, "memory", "SOUL.md");
     mkdirSync(dirname(soulPath), { recursive: true });
     copyFileSync(presetPath, soulPath);
     return true;
   }
   ```

   Export from @tek/db barrel (packages/db/src/index.ts).

   **In init.ts onComplete:**
   ```typescript
   import { recordAuditEvent, ensureMemoryFile, applyPersonalityPreset } from "@tek/db";

   // Handle personality
   if (result.personalityPreset && result.personalityPreset !== "custom" && result.personalityPreset !== "skip") {
     applyPersonalityPreset(result.personalityPreset);
   } else if (result.personalityPreset === "custom" || !result.personalityPreset) {
     ensureMemoryFile("BOOTSTRAP.md", "BOOTSTRAP.md");
   }
   // "skip" preset: do nothing, keep default SOUL.md
   ```

4. Update the config object to include new fields:
   ```typescript
   const config: AppConfig = {
     securityMode: result.securityMode,
     workspaceDir: result.workspaceDir ? resolvePath(result.workspaceDir) : undefined,
     apiEndpoint: { port: 3271, host: "127.0.0.1" },
     onboardingComplete: true,
     createdAt: new Date().toISOString(),
     defaultModel: result.defaultModel,
     modelAliases: result.modelAliases,
     agentName: result.agentName,
     userDisplayName: result.userDisplayName,
   };
   ```

5. Update @tek/db barrel export in packages/db/src/index.ts to include `applyPersonalityPreset`.

FILES ALSO MODIFIED (additions to Plan 01 artifacts):
- packages/db/src/memory/ensure-memory.ts (add applyPersonalityPreset)
- packages/db/src/index.ts (add export)
  </action>
  <verify>
    Run `cd /Users/hitekmedia/Documents/GitHub/tek && npx tsc --noEmit -p packages/cli/tsconfig.json && npx tsc --noEmit -p packages/db/tsconfig.json` — both must pass.
  </verify>
  <done>
    init.ts stores Telegram token in keychain via addKey. Named presets overwrite SOUL.md. Custom/undefined creates BOOTSTRAP.md. Config includes agentName and userDisplayName. @tek/db exports applyPersonalityPreset. TypeScript compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/cli/tsconfig.json` passes
2. `npx tsc --noEmit -p packages/db/tsconfig.json` passes
3. Onboarding.tsx has telegram-ask, telegram-input, hatch-ask, hatch-name steps
4. init.ts calls addKey("telegram", ...) for Telegram token
5. init.ts calls applyPersonalityPreset() for named presets
6. init.ts calls ensureMemoryFile("BOOTSTRAP.md", ...) for custom/deferred
7. Config object includes agentName and userDisplayName
</verification>

<success_criteria>
- Telegram bot token wizard step works end-to-end (ask -> input -> keychain)
- Personality Hatch step offers presets and naming
- Custom/skip creates BOOTSTRAP.md for deferred setup
- Named presets overwrite SOUL.md with preset content
- Onboarding flow is streamlined (under 12 screens worst case)
- All new data persisted to config.json and keychain
</success_criteria>

<output>
After completion, create `.planning/phases/15-init-onboarding-polish/15-03-SUMMARY.md`
</output>
