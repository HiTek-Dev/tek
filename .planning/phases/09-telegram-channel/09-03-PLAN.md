---
phase: 09-telegram-channel
plan: 03
type: execute
wave: 2
depends_on: ["09-01", "09-02"]
files_modified:
  - packages/telegram/src/auth/pairing.ts
  - packages/telegram/src/handlers/commands.ts
  - packages/telegram/src/handlers/message.ts
  - packages/telegram/src/bot.ts
  - packages/telegram/src/index.ts
  - packages/gateway/src/index.ts
autonomous: true
user_setup:
  - service: telegram
    why: "Telegram Bot API token required for bot operation"
    env_vars:
      - name: TELEGRAM_BOT_TOKEN
        source: "Create a bot via @BotFather on Telegram, copy the token"
    dashboard_config:
      - task: "Create a Telegram bot via @BotFather"
        location: "Telegram app -> message @BotFather -> /newbot"

must_haves:
  truths:
    - "grammY bot starts with long polling and responds to /start with a pairing code"
    - "Unauthenticated Telegram users cannot send messages to the agent — only /start and /pair are available"
    - "Paired Telegram users can send text messages that route through the same gateway handlers as CLI"
    - "Each Telegram message creates or reuses a session via the existing SessionManager"
  artifacts:
    - path: "packages/telegram/src/auth/pairing.ts"
      provides: "Pairing code generation, verification, and Telegram user lookup"
      exports: ["generatePairingCode", "verifyPairingCode", "getPairedUser"]
    - path: "packages/telegram/src/bot.ts"
      provides: "grammY Bot creation and middleware registration"
      exports: ["createTelegramBot", "startTelegramBot"]
    - path: "packages/telegram/src/handlers/message.ts"
      provides: "Text message handler bridging to gateway chat.send flow"
      exports: ["handleTelegramMessage"]
    - path: "packages/telegram/src/handlers/commands.ts"
      provides: "/start and /pair command handlers"
      exports: ["registerCommands"]
  key_links:
    - from: "packages/telegram/src/handlers/message.ts"
      to: "packages/gateway/src/ws/handlers.ts"
      via: "Calls handleChatSend with TelegramTransport"
      pattern: "handleChatSend"
    - from: "packages/telegram/src/auth/pairing.ts"
      to: "packages/db/src/schema/telegram.ts"
      via: "Drizzle queries on telegramUsers and pairingCodes"
      pattern: "telegramUsers|pairingCodes"
    - from: "packages/telegram/src/bot.ts"
      to: "packages/telegram/src/handlers/commands.ts"
      via: "bot.command registration"
      pattern: "bot.command"
---

<objective>
Build the grammY bot with pairing-code authentication and message routing to gateway handlers.

Purpose: This plan creates the core Telegram bot that users interact with. It implements the pairing-code authentication flow (TELE-05), the text message handler that bridges Telegram messages to the gateway's handleChatSend (TELE-01, TELE-02), and the command handlers for /start and /pair. After this plan, authenticated Telegram users can chat with their agent.

Output: Working Telegram bot with auth and message routing.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-telegram-channel/09-RESEARCH.md
@.planning/phases/09-telegram-channel/09-01-SUMMARY.md
@.planning/phases/09-telegram-channel/09-02-SUMMARY.md
@packages/gateway/src/ws/handlers.ts
@packages/gateway/src/ws/connection.ts
@packages/gateway/src/transport.ts
@packages/telegram/src/transport.ts
@packages/db/src/schema/telegram.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Pairing code authentication module</name>
  <files>
    packages/telegram/src/auth/pairing.ts
  </files>
  <action>
Create `packages/telegram/src/auth/pairing.ts` with these functions:

**generatePairingCode(telegramChatId: number, telegramUsername: string | null): string**
- Generate a 6-character alphanumeric code (uppercase letters + digits) using nanoid with a custom alphabet: `0123456789ABCDEFGHJKLMNPQRSTUVWXYZ` (no I, O to avoid ambiguity).
- Insert a row into `pairing_codes` table with:
  - code: the generated code
  - telegramChatId
  - telegramUsername
  - createdAt: new Date().toISOString()
  - expiresAt: 1 hour from now
  - used: false
- Return the code string.

**verifyPairingCode(code: string): { chatId: number; username: string | null } | null**
- Look up the code in `pairing_codes` table.
- If not found, or `used === true`, or `expiresAt < now`, return null.
- Otherwise, mark code as `used = true`.
- Insert or update a row in `telegram_users`:
  - id: nanoid()
  - telegramChatId: from the pairing code record
  - telegramUsername
  - pairedAt: new Date().toISOString()
  - active: true
- If a telegram_users row already exists for this chatId (user re-pairing), update pairedAt and active.
- Return `{ chatId, username }`.

**getPairedUser(telegramChatId: number): { id: string; active: boolean } | null**
- Query `telegram_users` where `telegramChatId = chatId AND active = true`.
- Return the row or null if not found.

**cleanExpiredCodes(): void**
- Delete all pairing_codes where `expiresAt < now` OR `used = true` and `createdAt` is more than 24 hours ago.
- Call this periodically (e.g., on bot start and every hour).

Use synchronous Drizzle queries via `getDb()` following existing patterns (e.g., `db.select().from(table).where(...).get()`). Import `eq`, `and`, `lt` from `drizzle-orm`.
  </action>
  <verify>
`pnpm --filter @agentspace/telegram exec tsc --noEmit` passes.
  </verify>
  <done>
Pairing code auth module generates 6-char codes, verifies them, links Telegram users to AgentSpace, and cleans expired codes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Bot setup, command handlers, and message handler</name>
  <files>
    packages/telegram/src/handlers/commands.ts
    packages/telegram/src/handlers/message.ts
    packages/telegram/src/bot.ts
    packages/telegram/src/index.ts
    packages/gateway/src/index.ts
  </files>
  <action>
**packages/telegram/src/handlers/commands.ts:**

Create `/start` and `/pair` command handlers:

```typescript
import type { CommandContext, Context } from "grammy";

export function registerCommands(bot: Bot): void {
  bot.command("start", handleStart);
  bot.command("pair", handlePair);
}
```

- `/start` handler: Call `getPairedUser(ctx.chat.id)`. If paired and active, reply "You're connected to AgentSpace. Send a message to chat with your agent." If not paired, call `generatePairingCode(ctx.chat.id, ctx.from?.username ?? null)` and reply with the code: "Welcome to AgentSpace! Your pairing code is: <code>ABC123</code>\n\nEnter this code in your CLI: agentspace pair telegram ABC123\n\nCode expires in 1 hour."
- `/pair` handler: Same as /start for unpaired users. For already-paired users, generate a new code (for re-pairing).

**packages/telegram/src/handlers/message.ts:**

Create the text message handler that bridges to the gateway:

```typescript
export async function handleTelegramMessage(ctx: Context, bot: Bot): Promise<void>
```

- Check `getPairedUser(ctx.chat!.id)`. If not paired, reply "Please pair first. Send /start for instructions." and return.
- Import `initConnection`, `getConnectionState` from `@agentspace/gateway` connection module. Import `handleChatSend` from gateway handlers (these must be exported — add to gateway index.ts if needed).
- Create or reuse a `TelegramTransport` for this chat. Use a module-level `Map<number, TelegramTransport>` keyed by chatId to reuse transports across messages from the same user.
- Get or init ConnectionState for the transport's transportId.
- Check if `connState.streaming` is true. If so, reply "Still processing your previous message. Please wait." and call `ctx.api.sendChatAction(ctx.chat!.id, "typing")`.
- Construct a `ChatSend` message: `{ type: "chat.send", id: nanoid(), content: ctx.message!.text!, sessionId: connState.sessionId ?? undefined }`.
- Call `handleChatSend(transport, chatSendMsg, connState)` — this routes through the same gateway path as CLI, creating sessions, assembling context, streaming LLM responses.
- Send `typing` chat action to indicate the bot is processing.

IMPORTANT: The `handleChatSend` function must be importable from `@agentspace/gateway`. Export it from `packages/gateway/src/index.ts`: `export { handleChatSend } from "./ws/handlers.js";`. Also export `initConnection`, `getConnectionState`, `removeConnection` from `packages/gateway/src/ws/index.ts` and then from `packages/gateway/src/index.ts`.

**packages/telegram/src/bot.ts:**

Create bot factory:

```typescript
import { Bot } from "grammy";
import { createLogger } from "@agentspace/core";
import { registerCommands } from "./handlers/commands.js";
import { handleTelegramMessage } from "./handlers/message.js";
import { cleanExpiredCodes } from "./auth/pairing.js";

const logger = createLogger("telegram-bot");

export function createTelegramBot(token: string): Bot {
  const bot = new Bot(token);

  registerCommands(bot);

  // Text message handler (after commands)
  bot.on("message:text", (ctx) => {
    handleTelegramMessage(ctx, bot).catch((err) => {
      logger.error(`Telegram message handler error: ${err.message}`);
    });
  });

  // Catch-all for unhandled callback queries (important per grammY docs)
  bot.on("callback_query:data", async (ctx) => {
    await ctx.answerCallbackQuery();
  });

  return bot;
}

export async function startTelegramBot(token: string): Promise<Bot> {
  const bot = createTelegramBot(token);

  // Clean expired pairing codes on start
  cleanExpiredCodes();

  // Clean expired codes every hour
  setInterval(() => cleanExpiredCodes(), 60 * 60 * 1000);

  // Start long polling
  bot.start({
    onStart: () => logger.info("Telegram bot started (long polling)"),
  });

  return bot;
}
```

**Update packages/telegram/src/index.ts** to export bot functions:
```typescript
export { createTelegramBot, startTelegramBot } from "./bot.js";
export { TelegramTransport } from "./transport.js";
export { formatForTelegram, escapeHtml, markdownToTelegramHtml } from "./formatter.js";
export { generatePairingCode, verifyPairingCode, getPairedUser } from "./auth/pairing.js";
```

**Update packages/gateway/src/index.ts** to export handler functions and connection state functions that the telegram package needs:
```typescript
export { handleChatSend } from "./ws/handlers.js";
export { initConnection, getConnectionState, removeConnection } from "./ws/connection.js";
```

Note: `handleChatSend` now accepts `Transport` (from Plan 09-01), so the Telegram package can call it directly with a TelegramTransport.
  </action>
  <verify>
`pnpm build` succeeds across all packages.
`pnpm --filter @agentspace/telegram exec tsc --noEmit` passes.
Verify the bot.ts imports compile and the handler chain is wired.
  </verify>
  <done>
Telegram bot starts with long polling, handles /start and /pair commands with pairing codes, bridges authenticated text messages to handleChatSend via TelegramTransport, and rejects unauthenticated users.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds
2. Bot can be instantiated with `createTelegramBot("test-token")`
3. Pairing code module generates 6-char alphanumeric codes
4. Message handler calls handleChatSend with TelegramTransport
5. Unauthenticated users are blocked from messaging
6. handleChatSend is exported from @agentspace/gateway
</verification>

<success_criteria>
- Telegram bot starts and responds to /start with pairing code
- Authenticated users can send messages routed through gateway
- Unauthenticated users see pairing instructions
- Sessions are managed by the same SessionManager as CLI
</success_criteria>

<output>
After completion, create `.planning/phases/09-telegram-channel/09-03-SUMMARY.md`
</output>
