---
phase: 09-telegram-channel
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/gateway/src/transport.ts
  - packages/gateway/src/ws/connection.ts
  - packages/gateway/src/ws/server.ts
  - packages/gateway/src/ws/handlers.ts
  - packages/gateway/src/agent/tool-loop.ts
  - packages/gateway/src/index.ts
autonomous: true

must_haves:
  truths:
    - "All gateway handlers accept Transport instead of WebSocket as first argument"
    - "ConnectionState is stored in Map<string, ConnectionState> keyed by transportId, not WeakMap<WebSocket>"
    - "WebSocket connections continue to work exactly as before via WebSocketTransport wrapper"
    - "Agent tool-loop sends messages via Transport.send() not raw ws.send()"
  artifacts:
    - path: "packages/gateway/src/transport.ts"
      provides: "Transport interface and WebSocketTransport implementation"
      exports: ["Transport", "WebSocketTransport"]
    - path: "packages/gateway/src/ws/connection.ts"
      provides: "ConnectionState management keyed by transport ID"
      contains: "Map<string, ConnectionState>"
  key_links:
    - from: "packages/gateway/src/ws/server.ts"
      to: "packages/gateway/src/transport.ts"
      via: "WebSocketTransport wrapping raw WebSocket in /gateway handler"
      pattern: "new WebSocketTransport"
    - from: "packages/gateway/src/ws/handlers.ts"
      to: "packages/gateway/src/transport.ts"
      via: "Transport parameter on all handler functions"
      pattern: "transport: Transport"
    - from: "packages/gateway/src/agent/tool-loop.ts"
      to: "packages/gateway/src/transport.ts"
      via: "AgentLoopOptions.transport replaces .socket"
      pattern: "transport: Transport"
---

<objective>
Introduce a Transport abstraction in the gateway so that handlers are channel-agnostic (WebSocket or Telegram).

Purpose: This is the prerequisite for Telegram integration. Currently all handlers accept `WebSocket` directly and call `send(ws, msg)`. By introducing a `Transport` interface with a `send(msg)` method, handlers become channel-agnostic. The existing WebSocket path continues to work via `WebSocketTransport`. The `ConnectionState` store changes from `WeakMap<WebSocket>` to `Map<string, ConnectionState>` keyed by transport ID, which also supports Telegram's persistent chat connections.

Output: Transport interface, WebSocketTransport class, refactored handlers/server/tool-loop.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-telegram-channel/09-RESEARCH.md
@packages/gateway/src/ws/connection.ts
@packages/gateway/src/ws/server.ts
@packages/gateway/src/ws/handlers.ts
@packages/gateway/src/agent/tool-loop.ts
@packages/gateway/src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Transport interface and WebSocketTransport wrapper</name>
  <files>
    packages/gateway/src/transport.ts
    packages/gateway/src/ws/connection.ts
    packages/gateway/src/index.ts
  </files>
  <action>
Create `packages/gateway/src/transport.ts` with:

```typescript
import type { ServerMessage } from "./ws/protocol.js";

/**
 * Transport abstracts message delivery to a client.
 * WebSocket and Telegram each implement this interface.
 */
export interface Transport {
  /** Send a typed server message to the client */
  send(msg: ServerMessage): void;
  /** Unique identifier for this transport (for connection state keying) */
  readonly transportId: string;
  /** Channel type identifier */
  readonly channel: "ws" | "telegram";
}
```

Create `WebSocketTransport` class in the same file:

```typescript
import type { WebSocket } from "ws";

export class WebSocketTransport implements Transport {
  readonly channel = "ws" as const;
  readonly transportId: string;

  constructor(private ws: WebSocket, id: string) {
    this.transportId = `ws:${id}`;
  }

  send(msg: ServerMessage): void {
    if (this.ws.readyState === this.ws.OPEN) {
      this.ws.send(JSON.stringify(msg));
    }
  }

  /** Access underlying WebSocket (for close event binding only) */
  get raw(): WebSocket {
    return this.ws;
  }
}
```

Refactor `packages/gateway/src/ws/connection.ts`:
- Change `connections` from `WeakMap<WebSocket, ConnectionState>` to `Map<string, ConnectionState>` (keyed by `transportId`).
- Change `initConnection(ws: WebSocket)` to `initConnection(transportId: string)` — no longer takes WebSocket, takes a string transport ID.
- Change `getConnectionState(ws: WebSocket)` to `getConnectionState(transportId: string)`.
- Change `markStreaming(ws, requestId)` to `markStreaming(transportId, requestId)`.
- Change `clearStreaming(ws)` to `clearStreaming(transportId)`.
- Change `isStreaming(ws)` to `isStreaming(transportId)`.
- Change `removeConnection(ws)` to `removeConnection(transportId)`.
- Remove the `import type { WebSocket } from "ws"` — no longer needed.

Export `Transport` and `WebSocketTransport` from `packages/gateway/src/index.ts` barrel.
  </action>
  <verify>
Run `cd /Users/hitekmedia/Documents/GitHub/AgentSpace && pnpm --filter @agentspace/gateway exec tsc --noEmit` and verify no type errors in the new/modified files (there will be errors in files that still reference the old signatures — those are fixed in Task 2).
  </verify>
  <done>
Transport interface and WebSocketTransport exist. ConnectionState store uses Map&lt;string&gt; instead of WeakMap&lt;WebSocket&gt;. Old connection.ts functions accept string transportId.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor handlers, server, and tool-loop to use Transport</name>
  <files>
    packages/gateway/src/ws/server.ts
    packages/gateway/src/ws/handlers.ts
    packages/gateway/src/agent/tool-loop.ts
  </files>
  <action>
**server.ts changes:**
- Import `WebSocketTransport` from `../transport.js` and `Transport` type.
- In the `/gateway` WebSocket handler, create a `WebSocketTransport` wrapping the raw socket: `const transport = new WebSocketTransport(socket, nanoid())` (import nanoid).
- Call `initConnection(transport.transportId)` instead of `initConnection(socket)`.
- Remove the local `send()` function. Use `transport.send(msg)` for the inline `session.list` and error responses.
- Pass `transport` instead of `socket` to all handler calls (e.g., `handleChatSend(transport, msg, connState)`).
- In `socket.on("close")`, call `removeConnection(transport.transportId)`.
- In `socket.on("error")`, call `removeConnection(transport.transportId)`.
- For `terminal.snapshot`, `terminal.control.grant`, `terminal.control.revoke` cases that only touch `connState`, no socket change needed — they don't call send.

**handlers.ts changes:**
This is a mechanical find-and-replace:
- Import `Transport` from `../transport.js` instead of `WebSocket` from `ws`.
- Change every handler's first parameter from `socket: WebSocket` to `transport: Transport`.
- Remove the local `send(ws, msg)` function. Replace all `send(socket, msg)` calls with `transport.send(msg)`.
- In `streamToClient`, change first param from `socket: WebSocket` to `transport: Transport`. Replace internal `send(socket, ...)` with `transport.send(...)`.
- In `handleChatSend`: `send(socket, ...)` → `transport.send(...)`.
- In `handlePreflightApproval`: same pattern.
- In `handleWorkflowTrigger`, `handleWorkflowApproval`, etc.: same pattern.
- In `handleHeartbeatConfigure`: the closure `send(socket, ...)` captures `socket` — change to capture `transport` and call `transport.send(...)`.
- The `runAgentLoop` call in `handleChatSend` and `handlePreflightApproval`: change `socket` to `transport` in the options object.

**tool-loop.ts changes:**
- Import `Transport` from `../transport.js` instead of `WebSocket` from `ws`.
- In `AgentLoopOptions`, change `socket: WebSocket` to `transport: Transport`.
- Remove the local `send(ws, msg)` function.
- Replace all `send(socket, msg)` with `transport.send(msg)` throughout `runAgentLoop`.
- In the destructured options, rename `socket` to `transport`.

IMPORTANT: This is purely mechanical. Every `send(socket, X)` becomes `transport.send(X)`. Every handler signature changes its first param type. No logic changes.
  </action>
  <verify>
Run `cd /Users/hitekmedia/Documents/GitHub/AgentSpace && pnpm --filter @agentspace/gateway exec tsc --noEmit` — full compilation must pass with zero errors.
Also run `cd /Users/hitekmedia/Documents/GitHub/AgentSpace && pnpm build` to verify the whole monorepo builds.
  </verify>
  <done>
All gateway handlers accept `Transport` instead of `WebSocket`. The agent tool-loop uses `transport.send()`. The full monorepo builds without errors. WebSocket connections work exactly as before via WebSocketTransport wrapper.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @agentspace/gateway exec tsc --noEmit` passes
2. `pnpm build` succeeds across all packages
3. `Transport` interface is exported from `@agentspace/gateway`
4. No remaining `import type { WebSocket } from "ws"` in handlers.ts
5. connection.ts uses `Map<string, ConnectionState>` not `WeakMap<WebSocket>`
</verification>

<success_criteria>
- Transport abstraction exists and is exported
- All handlers are channel-agnostic (accept Transport, not WebSocket)
- ConnectionState keyed by string transport ID
- Full monorepo builds without errors
</success_criteria>

<output>
After completion, create `.planning/phases/09-telegram-channel/09-01-SUMMARY.md`
</output>
