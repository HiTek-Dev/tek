---
phase: 09-telegram-channel
plan: 04
type: execute
wave: 3
depends_on: ["09-03"]
files_modified:
  - packages/telegram/src/streaming/accumulator.ts
  - packages/telegram/src/handlers/callback.ts
  - packages/telegram/src/transport.ts
  - packages/telegram/src/bot.ts
  - packages/telegram/src/handlers/message.ts
  - packages/telegram/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Streaming LLM responses are accumulated and sent as a single Telegram message, edited at most once per 2 seconds"
    - "Tool approval requests appear as Telegram messages with Approve/Deny inline buttons"
    - "Pressing Approve or Deny resolves the pending approval in ConnectionState"
    - "Long messages (>4096 chars) are split at paragraph boundaries into multiple Telegram messages"
    - "Agent responses display as clean HTML in Telegram with code blocks and bold formatting"
  artifacts:
    - path: "packages/telegram/src/streaming/accumulator.ts"
      provides: "TelegramResponseAccumulator that buffers deltas and throttles message edits"
      exports: ["TelegramResponseAccumulator"]
    - path: "packages/telegram/src/handlers/callback.ts"
      provides: "Inline button callback handler for tool approval"
      exports: ["registerCallbackHandlers"]
  key_links:
    - from: "packages/telegram/src/streaming/accumulator.ts"
      to: "packages/telegram/src/transport.ts"
      via: "Accumulator integrated into TelegramTransport.send() for stream delta messages"
      pattern: "chat.stream.delta"
    - from: "packages/telegram/src/handlers/callback.ts"
      to: "packages/gateway/src/ws/connection.ts"
      via: "Resolves pendingApprovals on ConnectionState"
      pattern: "pendingApprovals"
    - from: "packages/telegram/src/handlers/callback.ts"
      to: "packages/gateway/src/agent/approval-gate.ts"
      via: "recordSessionApproval for session-approve flow"
      pattern: "recordSessionApproval"
---

<objective>
Implement streaming response accumulation, response formatting, and inline tool approval buttons for Telegram.

Purpose: This plan completes the Telegram channel experience (TELE-03, TELE-04). LLM streaming responses are accumulated in a buffer and flushed to Telegram at a controlled rate (max 1 edit per 2 seconds) to avoid rate limits. Tool approval requests render as inline keyboard buttons. Agent responses are formatted as clean HTML without raw markdown artifacts.

Output: Streaming accumulator, tool approval callback handler, complete Telegram chat experience.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-telegram-channel/09-RESEARCH.md
@.planning/phases/09-telegram-channel/09-01-SUMMARY.md
@.planning/phases/09-telegram-channel/09-02-SUMMARY.md
@.planning/phases/09-telegram-channel/09-03-SUMMARY.md
@packages/telegram/src/transport.ts
@packages/telegram/src/formatter.ts
@packages/telegram/src/bot.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Streaming response accumulator with throttled edits</name>
  <files>
    packages/telegram/src/streaming/accumulator.ts
    packages/telegram/src/transport.ts
    packages/telegram/src/handlers/message.ts
  </files>
  <action>
Create `packages/telegram/src/streaming/accumulator.ts`:

```typescript
import type { Bot } from "grammy";
import { markdownToTelegramHtml } from "../formatter.js";
import { createLogger } from "@agentspace/core";

const logger = createLogger("telegram-accumulator");

/** Maximum Telegram message length */
const MAX_MESSAGE_LENGTH = 4096;

/** Minimum interval between message edits (ms) */
const EDIT_INTERVAL_MS = 2000;

export class TelegramResponseAccumulator {
  private buffer = "";
  private messageId: number | null = null;
  private lastEditTime = 0;
  private pendingTimer: ReturnType<typeof setTimeout> | null = null;

  constructor(
    private chatId: number,
    private bot: Bot,
  ) {}

  /** Append a text delta to the buffer and schedule a flush */
  async handleDelta(delta: string): Promise<void> {
    this.buffer += delta;

    const now = Date.now();
    if (now - this.lastEditTime >= EDIT_INTERVAL_MS) {
      await this.flush();
    } else if (!this.pendingTimer) {
      this.pendingTimer = setTimeout(
        () => this.flush().catch(() => {}),
        EDIT_INTERVAL_MS - (now - this.lastEditTime),
      );
    }
  }

  /** Flush buffered content to Telegram (send or edit) */
  async flush(): Promise<void> {
    if (!this.buffer.trim()) return;

    if (this.pendingTimer) {
      clearTimeout(this.pendingTimer);
      this.pendingTimer = null;
    }

    this.lastEditTime = Date.now();

    // Convert markdown to HTML for display
    const html = markdownToTelegramHtml(this.buffer);

    // Split if too long
    const chunks = splitMessage(html, MAX_MESSAGE_LENGTH);

    try {
      if (!this.messageId) {
        // Send initial message
        const sent = await this.bot.api.sendMessage(
          this.chatId,
          chunks[0],
          { parse_mode: "HTML" },
        );
        this.messageId = sent.message_id;

        // Send overflow chunks as separate messages
        for (let i = 1; i < chunks.length; i++) {
          await this.bot.api.sendMessage(this.chatId, chunks[i], {
            parse_mode: "HTML",
          });
        }
      } else {
        // Edit existing message (only the first chunk — overflow is rare mid-stream)
        await this.bot.api.editMessageText(
          this.chatId,
          this.messageId,
          chunks[0],
          { parse_mode: "HTML" },
        ).catch(() => {
          // Ignore "message not modified" errors
        });
      }
    } catch (err) {
      logger.error(`Telegram flush failed: ${err instanceof Error ? err.message : "unknown"}`);
    }
  }

  /** Final flush with complete response — converts full text to HTML */
  async finalize(): Promise<void> {
    if (this.pendingTimer) {
      clearTimeout(this.pendingTimer);
      this.pendingTimer = null;
    }
    await this.flush();
    this.reset();
  }

  /** Reset accumulator state for next response */
  private reset(): void {
    this.buffer = "";
    this.messageId = null;
    this.lastEditTime = 0;
  }
}

/**
 * Split a message at paragraph boundaries to fit within maxLength.
 * Falls back to hard split if no paragraph break is available.
 */
function splitMessage(text: string, maxLength: number): string[] {
  if (text.length <= maxLength) return [text];

  const chunks: string[] = [];
  let remaining = text;

  while (remaining.length > maxLength) {
    // Try to split at paragraph boundary
    let splitIdx = remaining.lastIndexOf("\n\n", maxLength);
    if (splitIdx <= 0) {
      // Fall back to single newline
      splitIdx = remaining.lastIndexOf("\n", maxLength);
    }
    if (splitIdx <= 0) {
      // Hard split
      splitIdx = maxLength;
    }

    chunks.push(remaining.slice(0, splitIdx));
    remaining = remaining.slice(splitIdx).trimStart();
  }

  if (remaining) chunks.push(remaining);
  return chunks;
}
```

**Integrate accumulator into TelegramTransport:**

Modify `packages/telegram/src/transport.ts`:
- Add a `private accumulators: Map<string, TelegramResponseAccumulator>` to track per-request accumulators.
- Override `send(msg)` to intercept `chat.stream.start`, `chat.stream.delta`, and `chat.stream.end`:
  - On `chat.stream.start`: Create a new accumulator for this `requestId`. Send typing indicator via `bot.api.sendChatAction(chatId, "typing")`.
  - On `chat.stream.delta`: Call `accumulator.handleDelta(msg.delta)`.
  - On `chat.stream.end`: Call `accumulator.finalize()`. Delete the accumulator.
- All other message types pass through to `formatForTelegram()` and `bot.api.sendMessage()` as before.

**Update message handler** to send typing indicator:
In `packages/telegram/src/handlers/message.ts`, before calling `handleChatSend`, start a typing indicator interval:
```typescript
const typingInterval = setInterval(() => {
  bot.api.sendChatAction(chatId, "typing").catch(() => {});
}, 4000);
```
Clear the interval when the response finishes (listen for streaming state change on connState, or use a wrapper). Simplest approach: set up a poll that clears when `connState.streaming === false`.
  </action>
  <verify>
`pnpm --filter @agentspace/telegram exec tsc --noEmit` passes.
  </verify>
  <done>
Streaming responses accumulate in a buffer and flush to Telegram at most once per 2 seconds. Long messages are split at paragraph boundaries. Typing indicator shows while processing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Inline keyboard tool approval buttons and callback handler</name>
  <files>
    packages/telegram/src/handlers/callback.ts
    packages/telegram/src/transport.ts
    packages/telegram/src/bot.ts
    packages/telegram/src/index.ts
  </files>
  <action>
Create `packages/telegram/src/handlers/callback.ts`:

```typescript
import type { Bot } from "grammy";
import { getConnectionState } from "@agentspace/gateway";
import { recordSessionApproval } from "@agentspace/gateway";
import { createLogger } from "@agentspace/core";

const logger = createLogger("telegram-callback");

/** Map from chatId to transportId for callback resolution */
const chatTransportMap = new Map<number, string>();

export function registerChatTransport(chatId: number, transportId: string): void {
  chatTransportMap.set(chatId, transportId);
}

export function registerCallbackHandlers(bot: Bot): void {
  // Tool approval callback: tool:approve:<toolCallId> or tool:deny:<toolCallId> or tool:session:<toolCallId>
  bot.callbackQuery(/^tool:(approve|deny|session):(.+)$/, async (ctx) => {
    const match = ctx.match!;
    const action = match[1];  // "approve" | "deny" | "session"
    const toolCallId = match[2];

    const chatId = ctx.callbackQuery.message?.chat?.id;
    if (!chatId) {
      await ctx.answerCallbackQuery({ text: "Error: unknown chat" });
      return;
    }

    const transportId = chatTransportMap.get(chatId);
    if (!transportId) {
      await ctx.answerCallbackQuery({ text: "Error: no active session" });
      return;
    }

    const connState = getConnectionState(transportId);
    if (!connState) {
      await ctx.answerCallbackQuery({ text: "Error: connection lost" });
      return;
    }

    const pending = connState.pendingApprovals.get(toolCallId);
    if (!pending) {
      await ctx.answerCallbackQuery({ text: "Approval expired or already handled" });
      return;
    }

    const approved = action !== "deny";

    // Session-approve: record so future calls skip approval
    if (action === "session" && connState.approvalPolicy) {
      recordSessionApproval(pending.toolName, connState.approvalPolicy);
      logger.info(`Session-approved tool "${pending.toolName}" via Telegram`);
    }

    pending.resolve(approved);

    await ctx.answerCallbackQuery({
      text: approved ? "Approved ✓" : "Denied ✗",
    });

    // Edit message to show decision
    const originalText = ctx.callbackQuery.message?.text ?? "";
    try {
      await ctx.editMessageText(
        `${originalText}\n\n<b>${approved ? "APPROVED" : "DENIED"}</b>`,
        { parse_mode: "HTML" },
      );
    } catch {
      // Ignore edit failures
    }
  });
}
```

**Intercept tool.approval.request in TelegramTransport:**

In `packages/telegram/src/transport.ts`, inside the `send(msg)` method, add handling for `tool.approval.request`:

```typescript
if (msg.type === "tool.approval.request") {
  const { InlineKeyboard } = await import("grammy");
  const keyboard = new InlineKeyboard()
    .text("Approve", `tool:approve:${msg.toolCallId}`)
    .text("Deny", `tool:deny:${msg.toolCallId}`)
    .row()
    .text("Approve for Session", `tool:session:${msg.toolCallId}`);

  const text = `<b>Tool Approval Required</b>\n\n`
    + `Tool: <code>${escapeHtml(msg.toolName)}</code>\n`
    + `Risk: ${msg.risk ?? "unknown"}\n\n`
    + `<pre>${escapeHtml(JSON.stringify(msg.args, null, 2).slice(0, 500))}</pre>`;

  this.bot.api.sendMessage(this.chatId, text, {
    parse_mode: "HTML",
    reply_markup: keyboard,
  }).catch((err: Error) => {
    logger.error(`Failed to send tool approval: ${err.message}`);
  });

  return; // Don't pass through to generic formatter
}
```

NOTE: The `tool.approval.request` ServerMessage type must have `toolCallId`, `toolName`, `args`, and optionally `risk` fields. Check the existing protocol.ts to confirm these field names and adjust if needed.

**Wire callback handlers into bot.ts:**

In `createTelegramBot()`, after `registerCommands(bot)`, add:
```typescript
registerCallbackHandlers(bot);
```

**Update message.ts** to register chat-transport mapping:
After creating/looking up the TelegramTransport, call:
```typescript
registerChatTransport(ctx.chat!.id, transport.transportId);
```

**Update packages/telegram/src/index.ts** to export new modules:
```typescript
export { TelegramResponseAccumulator } from "./streaming/accumulator.js";
export { registerCallbackHandlers } from "./handlers/callback.js";
```
  </action>
  <verify>
`pnpm build` succeeds across all packages.
`pnpm --filter @agentspace/telegram exec tsc --noEmit` passes.
Verify that `tool.approval.request` handling compiles correctly by checking the ServerMessage discriminated union includes it with the expected fields.
  </verify>
  <done>
Tool approval requests render as Telegram inline buttons (Approve/Deny/Approve for Session). Pressing a button resolves the pending approval. Streaming responses are accumulated and flushed at a controlled rate. Complete Telegram chat experience works end-to-end.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds
2. TelegramResponseAccumulator buffers deltas and edits messages at 2s intervals
3. splitMessage breaks text at paragraph boundaries under 4096 chars
4. InlineKeyboard renders Approve/Deny/Approve-for-Session buttons
5. Callback handler resolves pendingApprovals from ConnectionState
6. Session-approve via Telegram records approval in policy
</verification>

<success_criteria>
- Streaming responses appear as a single updating Telegram message
- Tool approvals show inline buttons and resolve correctly
- Long responses split into multiple messages
- Typing indicator shows while agent is processing
</success_criteria>

<output>
After completion, create `.planning/phases/09-telegram-channel/09-04-SUMMARY.md`
</output>
