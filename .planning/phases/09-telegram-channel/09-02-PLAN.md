---
phase: 09-telegram-channel
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/src/schema/telegram.ts
  - packages/db/src/schema/index.ts
  - packages/db/src/index.ts
  - packages/db/src/connection.ts
  - packages/telegram/package.json
  - packages/telegram/tsconfig.json
  - packages/telegram/src/index.ts
  - packages/telegram/src/transport.ts
  - packages/telegram/src/formatter.ts
autonomous: true

must_haves:
  truths:
    - "telegram_users and pairing_codes tables exist in SQLite and are auto-created by getDb()"
    - "Telegram package exists as @agentspace/telegram with grammy dependency"
    - "TelegramTransport implements the Transport interface from @agentspace/gateway"
    - "Response formatter converts ServerMessage to HTML-formatted Telegram text"
  artifacts:
    - path: "packages/db/src/schema/telegram.ts"
      provides: "telegramUsers and pairingCodes Drizzle table schemas"
      exports: ["telegramUsers", "pairingCodes"]
    - path: "packages/telegram/package.json"
      provides: "Telegram package with grammy dependency"
      contains: "grammy"
    - path: "packages/telegram/src/transport.ts"
      provides: "TelegramTransport class implementing Transport"
      exports: ["TelegramTransport"]
    - path: "packages/telegram/src/formatter.ts"
      provides: "formatForTelegram function converting ServerMessage to HTML text"
      exports: ["formatForTelegram", "escapeHtml"]
  key_links:
    - from: "packages/telegram/src/transport.ts"
      to: "packages/gateway/src/transport.ts"
      via: "implements Transport interface"
      pattern: "implements Transport"
    - from: "packages/db/src/schema/index.ts"
      to: "packages/db/src/schema/telegram.ts"
      via: "barrel re-export"
      pattern: "telegramUsers.*pairingCodes"
---

<objective>
Create the Telegram package scaffold and DB schemas for Telegram user authentication.

Purpose: This plan sets up the @agentspace/telegram package with grammY, creates the DB tables needed for pairing-code authentication (telegram_users and pairing_codes), and implements the TelegramTransport that bridges grammY's chat API to the gateway's Transport interface. It also creates the response formatter that converts server messages to Telegram-safe HTML.

Output: New @agentspace/telegram package, DB schemas, TelegramTransport, response formatter.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-telegram-channel/09-RESEARCH.md
@packages/db/src/schema/index.ts
@packages/db/src/index.ts
@packages/db/src/connection.ts
@packages/gateway/src/transport.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: DB schemas for telegram_users and pairing_codes</name>
  <files>
    packages/db/src/schema/telegram.ts
    packages/db/src/schema/index.ts
    packages/db/src/index.ts
    packages/db/src/connection.ts
  </files>
  <action>
Create `packages/db/src/schema/telegram.ts`:

```typescript
import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core";

export const telegramUsers = sqliteTable("telegram_users", {
  id: text("id").primaryKey(),              // nanoid
  telegramChatId: integer("telegram_chat_id").notNull().unique(),
  telegramUsername: text("telegram_username"),
  pairedAt: text("paired_at").notNull(),    // ISO timestamp
  active: integer("active", { mode: "boolean" }).notNull().default(true),
});

export const pairingCodes = sqliteTable("pairing_codes", {
  code: text("code").primaryKey(),           // 6 alphanumeric chars
  telegramChatId: integer("telegram_chat_id").notNull(),
  telegramUsername: text("telegram_username"),
  createdAt: text("created_at").notNull(),   // ISO timestamp
  expiresAt: text("expires_at").notNull(),   // createdAt + 1 hour
  used: integer("used", { mode: "boolean" }).notNull().default(false),
});
```

Add exports to `packages/db/src/schema/index.ts`:
```typescript
export { telegramUsers, pairingCodes } from "./telegram.js";
```

Add exports to `packages/db/src/index.ts`:
```typescript
export { telegramUsers, pairingCodes } from "./schema/index.js";
```

In `packages/db/src/connection.ts`, inside the `getDb()` function where tables are auto-created (look for the existing pattern creating audit_log, sessions, etc.), add:
```sql
CREATE TABLE IF NOT EXISTS telegram_users (
  id TEXT PRIMARY KEY,
  telegram_chat_id INTEGER NOT NULL UNIQUE,
  telegram_username TEXT,
  paired_at TEXT NOT NULL,
  active INTEGER NOT NULL DEFAULT 1
);
CREATE TABLE IF NOT EXISTS pairing_codes (
  code TEXT PRIMARY KEY,
  telegram_chat_id INTEGER NOT NULL,
  telegram_username TEXT,
  created_at TEXT NOT NULL,
  expires_at TEXT NOT NULL,
  used INTEGER NOT NULL DEFAULT 0
);
```

Follow the exact same pattern used for existing table creation (raw SQL exec via `$client` or however the existing tables are created).
  </action>
  <verify>
Run `cd /Users/hitekmedia/Documents/GitHub/AgentSpace && pnpm --filter @agentspace/db exec tsc --noEmit` — zero type errors.
  </verify>
  <done>
telegram_users and pairing_codes tables are defined in Drizzle schema, exported from @agentspace/db, and auto-created by getDb().
  </done>
</task>

<task type="auto">
  <name>Task 2: Scaffold @agentspace/telegram package with TelegramTransport and formatter</name>
  <files>
    packages/telegram/package.json
    packages/telegram/tsconfig.json
    packages/telegram/src/index.ts
    packages/telegram/src/transport.ts
    packages/telegram/src/formatter.ts
  </files>
  <action>
1. Create `packages/telegram/package.json`:
```json
{
  "name": "@agentspace/telegram",
  "version": "0.1.0",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "import": "./dist/index.js",
      "types": "./dist/index.d.ts"
    }
  },
  "scripts": {
    "build": "tsc"
  },
  "dependencies": {
    "@agentspace/core": "workspace:*",
    "@agentspace/db": "workspace:*",
    "@agentspace/gateway": "workspace:*",
    "grammy": "^1.40.0",
    "nanoid": "^5.1.6"
  },
  "devDependencies": {
    "@types/node": "^25.2.3"
  }
}
```

2. Create `packages/telegram/tsconfig.json` following the same pattern as other packages (extends shared config, outDir dist, rootDir src, composite true, references to workspace deps).

3. Run `cd /Users/hitekmedia/Documents/GitHub/AgentSpace && pnpm install` to resolve the new package.

4. Create `packages/telegram/src/formatter.ts`:

```typescript
import type { ServerMessage } from "@agentspace/gateway";

/** Escape HTML special characters for Telegram HTML parse_mode */
export function escapeHtml(text: string): string {
  return text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

/** Convert markdown-style formatting to Telegram HTML */
export function markdownToTelegramHtml(text: string): string {
  return text
    .replace(/```(\w*)\n?([\s\S]*?)```/g, "<pre>$2</pre>")
    .replace(/`([^`]+)`/g, "<code>$1</code>")
    .replace(/\*\*([^*]+)\*\*/g, "<b>$1</b>")
    .replace(/\*([^*]+)\*/g, "<i>$1</i>")
    .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>');
}

export interface FormattedMessage {
  text: string;
  replyMarkup?: unknown; // InlineKeyboard — typed loosely to avoid grammy import here
}

/**
 * Convert a gateway ServerMessage to a Telegram-formatted message.
 * Returns null for message types that should not be sent to Telegram
 * (e.g., stream deltas are accumulated separately).
 */
export function formatForTelegram(msg: ServerMessage): FormattedMessage | null {
  switch (msg.type) {
    case "chat.stream.start":
      return null; // Handled by accumulator
    case "chat.stream.delta":
      return null; // Handled by accumulator
    case "chat.stream.end":
      return null; // Handled by accumulator

    case "error":
      return { text: `<b>Error:</b> ${escapeHtml(msg.message)}` };

    case "session.created":
      return { text: `Session started: <code>${escapeHtml(msg.sessionId)}</code>` };

    case "tool.call":
      return {
        text: `<b>Tool Call:</b> <code>${escapeHtml(msg.toolName)}</code>\n`
            + `<pre>${escapeHtml(JSON.stringify(msg.args, null, 2).slice(0, 500))}</pre>`,
      };

    case "tool.result":
      return {
        text: `<b>Tool Result:</b> <code>${escapeHtml(msg.toolName)}</code>\n`
            + `<pre>${escapeHtml(String(msg.output).slice(0, 1000))}</pre>`,
      };

    // tool.approval.request handled separately with inline keyboard

    default:
      return null;
  }
}
```

Note: The formatter handles common message types. `tool.approval.request` is intentionally excluded — it gets special handling with inline keyboard buttons in a later plan.

5. Create `packages/telegram/src/transport.ts`:

```typescript
import type { Bot } from "grammy";
import type { Transport } from "@agentspace/gateway";
import type { ServerMessage } from "@agentspace/gateway";
import { formatForTelegram } from "./formatter.js";
import { createLogger } from "@agentspace/core";

const logger = createLogger("telegram-transport");

/**
 * TelegramTransport sends gateway ServerMessages to a Telegram chat.
 * Implements the Transport interface so gateway handlers are channel-agnostic.
 */
export class TelegramTransport implements Transport {
  readonly channel = "telegram" as const;
  readonly transportId: string;

  constructor(
    private chatId: number,
    private bot: Bot,
  ) {
    this.transportId = `tg:${chatId}`;
  }

  send(msg: ServerMessage): void {
    const formatted = formatForTelegram(msg);
    if (formatted) {
      this.bot.api.sendMessage(this.chatId, formatted.text, {
        parse_mode: "HTML",
        ...(formatted.replyMarkup ? { reply_markup: formatted.replyMarkup as any } : {}),
      }).catch((err: Error) => {
        logger.error(`Telegram send failed for chat ${this.chatId}: ${err.message}`);
      });
    }
  }

  /** Get the Telegram chat ID (for direct API calls like editMessage) */
  getChatId(): number {
    return this.chatId;
  }

  /** Get the bot instance (for direct API calls) */
  getBot(): Bot {
    return this.bot;
  }
}
```

6. Create `packages/telegram/src/index.ts`:
```typescript
export { TelegramTransport } from "./transport.js";
export { formatForTelegram, escapeHtml, markdownToTelegramHtml } from "./formatter.js";
export type { FormattedMessage } from "./formatter.js";
```

IMPORTANT: The `Transport` type import from `@agentspace/gateway` requires that Plan 09-01 has run first for the types to exist. However, the file can be created now — it will compile once 09-01 is also complete. Since both plans are in Wave 1, the build step happens after both complete.
  </action>
  <verify>
Run `cd /Users/hitekmedia/Documents/GitHub/AgentSpace && pnpm install && pnpm build` — full monorepo builds without errors.
Verify `packages/telegram/dist/` contains compiled output.
  </verify>
  <done>
@agentspace/telegram package exists with grammy dependency, TelegramTransport implementing Transport, response formatter with HTML escaping, and DB schemas for telegram auth.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` succeeds across all packages including @agentspace/telegram
2. `telegramUsers` and `pairingCodes` are exported from `@agentspace/db`
3. `TelegramTransport` class implements `Transport` interface
4. `formatForTelegram` converts error/tool messages to HTML
5. `escapeHtml` properly escapes &lt; &gt; &amp;
</verification>

<success_criteria>
- @agentspace/telegram package compiles with grammy installed
- DB tables telegram_users and pairing_codes auto-created
- TelegramTransport sends formatted HTML messages via bot.api
- Formatter handles common ServerMessage types
</success_criteria>

<output>
After completion, create `.planning/phases/09-telegram-channel/09-02-SUMMARY.md`
</output>
