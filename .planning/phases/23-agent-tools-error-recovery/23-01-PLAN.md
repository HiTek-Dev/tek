---
phase: 23-agent-tools-error-recovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/gateway/src/tools/filesystem.ts
  - packages/gateway/src/tools/shell.ts
  - packages/gateway/src/tools/fetch.ts
  - packages/gateway/src/agent/tool-loop.ts
  - packages/gateway/src/agent/tool-registry.ts
  - packages/gateway/src/ws/protocol.ts
autonomous: true
requirements:
  - TOOLS-PATH
  - TOOLS-ERROR
  - TOOLS-FREEZE
  - TOOLS-FETCH
  - TOOLS-DELETE

must_haves:
  truths:
    - "File tools resolve relative paths against agent workspace directory"
    - "Shell tool uses workspace as default cwd"
    - "Tool errors are relayed to client as tool.error WS messages"
    - "Agent never freezes silently after a tool failure"
    - "Agent can delete files via delete_file tool"
    - "Agent can make HTTP requests via fetch_url tool"
  artifacts:
    - path: "packages/gateway/src/tools/filesystem.ts"
      provides: "Path-resolved filesystem tools including delete_file"
      contains: "resolveAgentPath"
    - path: "packages/gateway/src/tools/shell.ts"
      provides: "Workspace-aware shell tool"
      contains: "resolveAgentPath"
    - path: "packages/gateway/src/tools/fetch.ts"
      provides: "HTTP fetch tool for making web requests"
      contains: "fetch_url"
    - path: "packages/gateway/src/agent/tool-loop.ts"
      provides: "Tool error relay to client"
      contains: "tool-error"
    - path: "packages/gateway/src/ws/protocol.ts"
      provides: "ToolErrorNotify schema"
      contains: "tool.error"
  key_links:
    - from: "packages/gateway/src/tools/filesystem.ts"
      to: "workspaceDir parameter"
      via: "resolveAgentPath before checkWorkspace"
      pattern: "resolveAgentPath"
    - from: "packages/gateway/src/agent/tool-loop.ts"
      to: "transport.send"
      via: "tool-error case in fullStream switch"
      pattern: "case.*tool-error"
    - from: "packages/gateway/src/agent/tool-registry.ts"
      to: "packages/gateway/src/tools/fetch.ts"
      via: "import and registration of fetch tool"
      pattern: "createFetchTool"
---

<objective>
Fix broken tool workspace paths, add tool error reporting, add delete_file tool, and add HTTP fetch tool.

Purpose: Tools currently pass LLM-hallucinated paths (e.g. /home/user/) straight through without resolution, causing ENOENT errors. Tool errors are silently swallowed because the fullStream handler has no `tool-error` case, causing the agent to freeze. The base tool set is missing delete_file (SC1 requires file CRUD) and fetch_url (SC6 requires HTTP requests). These are the highest-impact gaps from sandbox testing.

Output: Workspace-aware filesystem/shell tools, delete_file tool, HTTP fetch tool, and client-visible tool error messages.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-agent-tools-error-recovery/23-RESEARCH.md
@packages/gateway/src/tools/filesystem.ts
@packages/gateway/src/tools/shell.ts
@packages/gateway/src/agent/tool-loop.ts
@packages/gateway/src/agent/tool-registry.ts
@packages/gateway/src/ws/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workspace path resolution, delete_file, and fetch tool to filesystem/shell tools</name>
  <files>
    packages/gateway/src/tools/filesystem.ts
    packages/gateway/src/tools/shell.ts
    packages/gateway/src/tools/fetch.ts
    packages/gateway/src/agent/tool-registry.ts
  </files>
  <action>
In filesystem.ts:
1. Import `resolve` and `isAbsolute` from `node:path`, and `unlink` from `node:fs/promises`
2. Add a `resolveAgentPath` helper function:
   - If path is absolute, return as-is (checkWorkspace will enforce security)
   - If relative and workspaceDir provided, return `resolve(workspaceDir, path)`
   - If relative and no workspaceDir, return `resolve(path)` (resolves against cwd)
3. In read_file execute: call `resolveAgentPath(path, workspaceDir)` BEFORE `checkWorkspace`
4. In write_file execute: same pattern
5. In list_files execute: apply to directory arg
6. Add a `delete_file` tool:
   ```typescript
   const delete_file = tool({
     description: "Delete a file at the given path. Paths are relative to your workspace directory.",
     inputSchema: z.object({
       path: z.string().describe("File path to delete (relative to workspace)"),
     }),
     execute: async ({ path: rawPath }) => {
       const path = resolveAgentPath(rawPath, workspaceDir);
       checkWorkspace(path, securityMode, workspaceDir);
       await unlink(path);
       return `Deleted ${path}`;
     },
   });
   ```
7. Update return to include delete_file: `return { read_file, write_file, list_files, delete_file };`
8. Update tool descriptions to say "Paths are relative to your workspace directory" so the LLM knows to use relative paths

In shell.ts:
1. Import `resolve` and `isAbsolute` from `node:path`
2. Add same `resolveAgentPath` helper (keep it local since it's 3 lines)
3. When cwd is provided and relative, resolve against workspaceDir
4. When no cwd provided at all, default to workspaceDir (even in full-control mode -- it's a sensible default, not a restriction)
5. Update tool description to mention workspace directory context

Create packages/gateway/src/tools/fetch.ts:
1. Import `tool` from "ai" and `z` from "zod"
2. Export `createFetchTool()` that returns a `fetch_url` tool:
   ```typescript
   export function createFetchTool() {
     return tool({
       description: "Make an HTTP request to a URL. Supports GET, POST, PUT, PATCH, DELETE methods. Returns the response status, headers, and body.",
       inputSchema: z.object({
         url: z.string().url().describe("The URL to fetch"),
         method: z.enum(["GET", "POST", "PUT", "PATCH", "DELETE"]).optional().default("GET").describe("HTTP method"),
         headers: z.record(z.string()).optional().describe("Optional request headers"),
         body: z.string().optional().describe("Optional request body (for POST/PUT/PATCH)"),
       }),
       execute: async ({ url, method, headers, body }) => {
         const controller = new AbortController();
         const timeout = setTimeout(() => controller.abort(), 30_000); // 30s timeout
         try {
           const response = await fetch(url, {
             method,
             headers,
             body: body && ["POST", "PUT", "PATCH"].includes(method) ? body : undefined,
             signal: controller.signal,
           });
           const responseBody = await response.text();
           // Truncate large responses
           const maxSize = 100 * 1024; // 100KB
           const truncated = responseBody.length > maxSize
             ? responseBody.slice(0, maxSize) + `\n\n[TRUNCATED: response is ${responseBody.length} bytes, showing first ${maxSize} bytes]`
             : responseBody;
           return {
             status: response.status,
             statusText: response.statusText,
             headers: Object.fromEntries(response.headers.entries()),
             body: truncated,
           };
         } catch (err) {
           return { error: err instanceof Error ? err.message : String(err) };
         } finally {
           clearTimeout(timeout);
         }
       },
     });
   }
   ```

In packages/gateway/src/agent/tool-registry.ts:
1. Import `createFetchTool` from `../tools/fetch.js`
2. After the shell tool registration (section 2), add fetch tool registration:
   ```typescript
   // 2b. Add built-in fetch tool
   const fetchTool = createFetchTool();
   const fetchName = "fetch_url";
   tools[fetchName] = approvalPolicy
     ? wrapToolWithApproval(fetchName, fetchTool as unknown as Record<string, unknown>, approvalPolicy)
     : fetchTool;
   // Fetch is read-mostly: use "session" tier (can POST to external services)
   if (approvalPolicy) {
     approvalPolicy.perTool[fetchName] = "session";
   }
   ```
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/gateway/tsconfig.json` -- should compile with no errors. Grep for `resolveAgentPath` in filesystem.ts and shell.ts. Grep for `delete_file` in filesystem.ts. Grep for `fetch_url` in fetch.ts and tool-registry.ts. Grep for `createFetchTool` in tool-registry.ts.
  </verify>
  <done>
All filesystem tool execute functions resolve relative paths against workspaceDir before passing to checkWorkspace. Shell tool defaults cwd to workspaceDir. delete_file tool exists and works with workspace path resolution. fetch_url tool exists and is registered in the tool registry. Tool descriptions mention workspace-relative paths.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tool-error handling to agent loop and WS protocol</name>
  <files>
    packages/gateway/src/agent/tool-loop.ts
    packages/gateway/src/ws/protocol.ts
  </files>
  <action>
In protocol.ts:
1. Add a `ToolErrorNotifySchema` Zod schema:
   ```
   type: z.literal("tool.error"),
   requestId: z.string(),
   toolCallId: z.string(),
   toolName: z.string(),
   error: z.string(),
   ```
2. Add `ToolErrorNotifySchema` to the `ServerMessageSchema` discriminated union array
3. Export the type: `export type ToolErrorNotify = z.infer<typeof ToolErrorNotifySchema>;`

In tool-loop.ts:
1. Add a `case "tool-error"` to the fullStream switch statement, placed after the existing `tool-result` case:
   ```typescript
   case "tool-error": {
     const toolCallId = part.toolCallId;
     const toolName = String(part.toolName);
     const errorMessage = part.error instanceof Error
       ? part.error.message
       : String(part.error);

     logger.warn(`Tool execution error [${toolName}]: ${errorMessage}`);

     transport.send({
       type: "tool.error",
       requestId,
       toolCallId,
       toolName,
       error: errorMessage,
     });
     break;
   }
   ```
2. Ensure the `default` case logs unexpected part types at info level (currently it silently ignores -- add `logger.info` for debugging)
  </action>
  <verify>
Run `npx tsc --noEmit -p packages/gateway/tsconfig.json` -- should compile. Grep for `tool-error` in tool-loop.ts and `tool.error` in protocol.ts to confirm both are present.
  </verify>
  <done>
Tool errors from AI SDK are caught in the fullStream handler and relayed to the client as `tool.error` WS messages. The agent loop no longer silently drops tool execution failures.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/gateway/tsconfig.json` passes
2. `resolveAgentPath` function exists in filesystem.ts and shell.ts
3. `delete_file` tool exists in filesystem.ts and is returned from createFilesystemTools
4. `fetch_url` tool exists in fetch.ts and is registered in tool-registry.ts
5. `tool-error` case exists in tool-loop.ts fullStream switch
6. `ToolErrorNotifySchema` exists in protocol.ts and is in the ServerMessage union
</verification>

<success_criteria>
- File tool paths are resolved relative to workspace before security checks
- Shell tool defaults cwd to workspace directory
- delete_file tool can remove files within workspace
- fetch_url tool can make HTTP requests with configurable method/headers/body
- Tool errors produce client-visible WS messages instead of being swallowed
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/23-agent-tools-error-recovery/23-01-SUMMARY.md`
</output>
