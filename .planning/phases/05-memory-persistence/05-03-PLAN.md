---
phase: 05-memory-persistence
plan: 03
type: execute
wave: 3
depends_on: ["05-02"]
files_modified:
  - packages/db/src/memory/vector-search.ts
  - packages/db/src/memory/index.ts
  - packages/gateway/src/memory/memory-manager.ts
  - packages/gateway/src/memory/pressure-detector.ts
  - packages/gateway/src/memory/thread-manager.ts
  - packages/gateway/src/memory/index.ts
  - packages/gateway/src/context/assembler.ts
  - packages/gateway/src/ws/protocol.ts
  - packages/gateway/src/ws/handlers.ts
  - packages/gateway/src/ws/server.ts
  - packages/gateway/src/index.ts
autonomous: true

must_haves:
  truths:
    - "User can search past conversations and memories using natural language queries that return semantically similar results"
    - "Agent context includes SOUL.md personality, MEMORY.md facts, and recent daily logs in every LLM call"
    - "Memory pressure triggers at 70% context utilization, flushing important info to daily log before compaction"
    - "User can create and switch between conversation threads with per-thread system prompts"
    - "User can manage global system prompts that apply across all threads"
    - "Thread and memory operations are accessible via WebSocket protocol messages"
  artifacts:
    - path: "packages/db/src/memory/vector-search.ts"
      provides: "KNN semantic search over vec_memories with metadata join"
      exports: ["searchMemories"]
    - path: "packages/gateway/src/memory/memory-manager.ts"
      provides: "Orchestrates all memory operations (daily flush, search, context building)"
      exports: ["MemoryManager"]
    - path: "packages/gateway/src/memory/pressure-detector.ts"
      provides: "Context window utilization monitoring with 70% threshold trigger"
      exports: ["MemoryPressureDetector"]
    - path: "packages/gateway/src/memory/thread-manager.ts"
      provides: "Thread CRUD, system prompt assembly (global + per-thread)"
      exports: ["ThreadManager"]
    - path: "packages/gateway/src/context/assembler.ts"
      provides: "Updated context assembler injecting soul, memory, daily logs into LLM context"
  key_links:
    - from: "packages/gateway/src/context/assembler.ts"
      to: "@agentspace/db memory functions"
      via: "loadSoul, loadLongTermMemory, loadRecentLogs imported from @agentspace/db"
      pattern: "loadSoul|loadLongTermMemory|loadRecentLogs"
    - from: "packages/gateway/src/memory/memory-manager.ts"
      to: "packages/db/src/memory/vector-search.ts"
      via: "searchMemories for semantic queries"
      pattern: "searchMemories"
    - from: "packages/gateway/src/ws/handlers.ts"
      to: "memory.search, thread.create, thread.list, thread.update, prompt.set, prompt.list"
      via: "WS protocol message dispatch"
      pattern: "memory\\.search|thread\\.|prompt\\."
---

<objective>
Wire vector search, memory pressure detection, thread management, and system prompt assembly into the gateway, completing the full memory and persistence system.

Purpose: Connect all memory infrastructure into the live gateway so that conversations benefit from persistent memory, soul personality, semantic search, and multi-thread management.
Output: Working vector search, memory-aware context assembly, pressure-triggered memory flush, thread CRUD with system prompts, and WS protocol extensions.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-memory-persistence/05-RESEARCH.md
@.planning/phases/05-memory-persistence/05-01-SUMMARY.md
@.planning/phases/05-memory-persistence/05-02-SUMMARY.md

@packages/gateway/src/context/assembler.ts
@packages/gateway/src/context/types.ts
@packages/gateway/src/ws/protocol.ts
@packages/gateway/src/ws/handlers.ts
@packages/gateway/src/ws/server.ts
@packages/gateway/src/index.ts
@packages/db/src/memory/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Vector search, memory pressure detector, and thread manager</name>
  <files>
    packages/db/src/memory/vector-search.ts
    packages/db/src/memory/index.ts
    packages/gateway/src/memory/memory-manager.ts
    packages/gateway/src/memory/pressure-detector.ts
    packages/gateway/src/memory/thread-manager.ts
    packages/gateway/src/memory/index.ts
    packages/gateway/src/index.ts
  </files>
  <action>
**Vector search (packages/db/src/memory/vector-search.ts):**

```typescript
export async function searchMemories(query: string, opts?: {
  topK?: number;
  threadId?: string;
}): Promise<Array<{ id: number; content: string; memoryType: string; distance: number; createdAt: string }>>
```

Implementation:
1. Generate query embedding via `generateEmbedding(query)`.
2. Convert to Uint8Array blob.
3. Use raw SQL via `(db as any).$client`:
```sql
WITH knn_matches AS (
  SELECT memory_id, distance
  FROM vec_memories
  WHERE content_embedding MATCH ?
    AND k = ?
)
SELECT m.id, m.content, m.memory_type, m.created_at, knn.distance
FROM knn_matches knn
LEFT JOIN memories m ON m.id = knn.memory_id
[WHERE m.thread_id = ? -- if threadId provided]
ORDER BY knn.distance ASC
```
Default topK = 10. Re-export from memory/index.ts.

**Memory pressure detector (packages/gateway/src/memory/pressure-detector.ts):**

```typescript
export class MemoryPressureDetector {
  constructor(private config: { maxContextTokens: number; triggerThreshold: number }) {}

  check(tokenCounts: { system: number; memory: number; conversation: number }): {
    shouldFlush: boolean;
    usage: number;
    remaining: number;
  }
}
```

Uses simple token count math: `total / maxContextTokens`. Default threshold 0.70. Uses `estimateTokenCount` from `tokenx` (already in gateway). No async — just math.

**Thread manager (packages/gateway/src/memory/thread-manager.ts):**

```typescript
export class ThreadManager {
  createThread(title: string, systemPrompt?: string): ThreadRow
  getThread(id: string): ThreadRow | undefined
  listThreads(includeArchived?: boolean): ThreadRow[]
  updateThread(id: string, updates: { title?: string; systemPrompt?: string; archived?: boolean }): void
  buildSystemPrompt(threadId?: string): string
}
```

- Uses Drizzle ORM with `threads` and `globalPrompts` schemas from @agentspace/db.
- `createThread` generates nanoid for ID, sets createdAt/lastActiveAt to now.
- `buildSystemPrompt` loads active global prompts (ordered by priority desc), appends thread-specific prompt if present. This is the raw system prompt text — soul/memory are added by the assembler.
- Thread IDs use nanoid (already in gateway deps).

**Global prompt operations (on ThreadManager):**
```typescript
  addGlobalPrompt(name: string, content: string, priority?: number): { id: number }
  listGlobalPrompts(): GlobalPromptRow[]
  updateGlobalPrompt(id: number, updates: { content?: string; isActive?: boolean; priority?: number }): void
  removeGlobalPrompt(id: number): void
```

**Memory manager (packages/gateway/src/memory/memory-manager.ts):**

Orchestration class that coordinates all memory operations:
```typescript
export class MemoryManager {
  constructor()

  // Context building — called by assembler
  getMemoryContext(): { soul: string; longTermMemory: string; recentLogs: string }

  // Search — called by WS handler
  async search(query: string, opts?: { topK?: number; threadId?: string }): Promise<SearchResult[]>

  // Store — called after conversations
  async storeMemory(content: string, opts: { threadId?: string; memoryType: string; source?: string }): Promise<void>

  // Flush — called when pressure detected
  async flushToDaily(content: string): Promise<void>
}
```

Uses `loadSoul`, `loadLongTermMemory`, `loadRecentLogs` from @agentspace/db. Uses `searchMemories`, `embedAndStore` from @agentspace/db. Uses `appendDailyLog` for flush operations.

Create `packages/gateway/src/memory/index.ts` barrel exporting MemoryManager, MemoryPressureDetector, ThreadManager.

Update `packages/gateway/src/index.ts` to re-export from memory/.
  </action>
  <verify>
`pnpm --filter @agentspace/gateway build` compiles without errors. Verify exports: MemoryManager, MemoryPressureDetector, ThreadManager, searchMemories.
  </verify>
  <done>
Vector search performs KNN queries against vec_memories with metadata join. Memory pressure detector monitors token usage at 70% threshold. Thread manager provides full CRUD for threads and global prompts with system prompt assembly. Memory manager orchestrates all memory operations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update context assembler and add WS protocol extensions</name>
  <files>
    packages/gateway/src/context/assembler.ts
    packages/gateway/src/ws/protocol.ts
    packages/gateway/src/ws/handlers.ts
    packages/gateway/src/ws/server.ts
  </files>
  <action>
**Update assembler.ts:**

Replace the hardcoded `SYSTEM_PROMPT` and empty memory stub with live data:

1. Import `MemoryManager` and `ThreadManager` from `../memory/index.js`.
2. Update `assembleContext` signature to accept optional `threadId?: string` parameter.
3. Replace `const SYSTEM_PROMPT = "You are a helpful AI assistant."` with:
   - Build system prompt from ThreadManager: `threadManager.buildSystemPrompt(threadId)` — or fall back to "You are a helpful AI assistant." if no thread/global prompts exist.
4. Replace the empty memory section with:
   - Get memory context from MemoryManager: `memoryManager.getMemoryContext()`
   - Create three measured sections: `soul` (SOUL.md content), `long_term_memory` (MEMORY.md content), `recent_activity` (daily logs).
   - Remove the old empty `memory` section.
5. Inject soul + memory into the system prompt string sent to the LLM:
   ```
   system = [userSystemPrompt, "\n\n# Your Identity\n" + soul, "\n\n# Long-Term Memory\n" + longTermMemory, "\n\n# Recent Activity\n" + recentLogs].filter(Boolean).join("\n")
   ```
6. Keep existing sections (history, skills, tools, user_message) unchanged.

Use singleton instances for MemoryManager and ThreadManager (lazy-init pattern matching SessionManager/UsageTracker).

**WS protocol extensions (protocol.ts):**

Add new message schemas following the existing discriminated union pattern (Zod schemas + add to ClientMessage/ServerMessage unions):

Client messages:
- `memory.search`: `{ type: 'memory.search', id: string, query: string, topK?: number, threadId?: string }`
- `thread.create`: `{ type: 'thread.create', id: string, title: string, systemPrompt?: string }`
- `thread.list`: `{ type: 'thread.list', id: string, includeArchived?: boolean }`
- `thread.update`: `{ type: 'thread.update', id: string, threadId: string, title?: string, systemPrompt?: string, archived?: boolean }`
- `prompt.set`: `{ type: 'prompt.set', id: string, name: string, content: string, priority?: number }`
- `prompt.list`: `{ type: 'prompt.list', id: string }`

Server messages:
- `memory.search.result`: `{ type: 'memory.search.result', id: string, results: Array<{ content: string, memoryType: string, distance: number, createdAt: string }> }`
- `thread.created`: `{ type: 'thread.created', id: string, thread: { id: string, title: string, systemPrompt?: string, createdAt: string } }`
- `thread.list.result`: `{ type: 'thread.list.result', id: string, threads: Array<ThreadRow> }`
- `thread.updated`: `{ type: 'thread.updated', id: string, threadId: string }`
- `prompt.set.result`: `{ type: 'prompt.set.result', id: string, promptId: number }`
- `prompt.list.result`: `{ type: 'prompt.list.result', id: string, prompts: Array<GlobalPromptRow> }`

Follow the exact same pattern used for `chat.route.propose`/`chat.route.confirm` in Phase 04-02.

**WS handlers (handlers.ts):**

Add handler functions for each new message type. Each handler:
1. Receives parsed message + WebSocket
2. Calls appropriate manager method
3. Sends response message

Wire handlers in server.ts message dispatch switch.

**Memory pressure integration:**

In the chat.send handler (or streamToClient helper), after assembling context:
1. Create MemoryPressureDetector with model's max context (200k for Claude, 128k for GPT-4, configurable).
2. Check pressure using assembled context token totals.
3. If shouldFlush: call `memoryManager.flushToDaily()` with a summary of older messages, then reassemble context with trimmed history.
4. This is best-effort — if flush fails, proceed anyway.
  </action>
  <verify>
1. `pnpm --filter @agentspace/gateway build` compiles without errors.
2. Verify assembler now produces non-empty soul, long_term_memory, and recent_activity sections.
3. Verify protocol.ts includes all 6 client message types and 6 server message types.
4. Verify handlers.ts has handler functions for memory.search, thread.*, prompt.*.
5. Verify server.ts dispatches all new message types.
  </verify>
  <done>
Context assembler injects SOUL.md, MEMORY.md, and daily logs into every LLM call. Memory search available via WS `memory.search` with KNN results. Thread CRUD via `thread.create/list/update`. Global prompt management via `prompt.set/list`. Memory pressure auto-flushes at 70% utilization. All 5 Phase 5 success criteria are met.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @agentspace/gateway build` passes
2. Context assembler produces sections: system_prompt (with global/thread prompts), soul, long_term_memory, recent_activity, history, user_message
3. WS protocol supports: memory.search, thread.create, thread.list, thread.update, prompt.set, prompt.list
4. Memory pressure detector triggers at 70% and flushes to daily log
5. Vector search returns semantically similar results ordered by distance
6. Thread system prompt assembly merges global prompts (by priority) + thread-specific prompt
</verification>

<success_criteria>
- Context assembler sends SOUL.md personality, MEMORY.md facts, and daily logs to every LLM call
- Semantic search via memory.search returns relevant past memories with distance scores
- Memory pressure triggers at 70% utilization and preserves information via daily log flush
- Thread CRUD works via WS protocol with per-thread system prompts
- Global system prompts manageable via WS protocol with priority ordering
- All Phase 5 success criteria from ROADMAP.md are satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/05-memory-persistence/05-03-SUMMARY.md`
</output>
