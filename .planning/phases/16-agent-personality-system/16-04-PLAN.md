---
phase: 16-agent-personality-system
plan: 04
type: execute
wave: 3
depends_on: ["16-03"]
files_modified:
  - packages/gateway/src/ws/protocol.ts
  - packages/gateway/src/ws/handlers.ts
  - packages/gateway/src/ws/server.ts
  - packages/db/src/memory/soul-manager.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "WS protocol supports soul.evolution.propose (server->client) and soul.evolution.response (client->server)"
    - "Handler writes approved content to the specified identity file section"
    - "Evolution proposals follow existing tool.approval.request/response pattern"
    - "Rate limiting: max 1 evolution proposal per session"
  artifacts:
    - path: "packages/gateway/src/ws/protocol.ts"
      provides: "SoulEvolutionProposeSchema, SoulEvolutionResponseSchema in discriminated unions"
      contains: "soul.evolution"
    - path: "packages/gateway/src/ws/handlers.ts"
      provides: "handleSoulEvolutionResponse function"
      contains: "handleSoulEvolutionResponse"
    - path: "packages/db/src/memory/soul-manager.ts"
      provides: "updateIdentityFileSection() for writing approved evolution content"
      exports: ["updateIdentityFileSection"]
  key_links:
    - from: "packages/gateway/src/ws/handlers.ts"
      to: "packages/db/src/memory/soul-manager.ts"
      via: "updateIdentityFileSection() call"
      pattern: "updateIdentityFileSection"
    - from: "packages/gateway/src/ws/protocol.ts"
      to: "packages/gateway/src/ws/handlers.ts"
      via: "SoulEvolutionResponse type used in handler signature"
      pattern: "SoulEvolutionResponse"
---

<objective>
Add soul evolution WS protocol messages and handler for the personality evolution mechanism: the agent proposes changes to identity files, the user approves/edits/rejects, and approved changes are written.

Purpose: Enables the agent to evolve its personality over time through diff-style proposals with explicit user approval, preventing unauthorized personality drift.
Output: Protocol schema extensions, evolution handler, identity file section updater.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-agent-personality-system/16-03-SUMMARY.md
@packages/gateway/src/ws/protocol.ts
@packages/gateway/src/ws/handlers.ts
@packages/db/src/memory/soul-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add soul evolution schemas to WS protocol</name>
  <files>packages/gateway/src/ws/protocol.ts</files>
  <action>
    Add two new schemas in protocol.ts. Place them near the existing ToolApprovalRequest/Response schemas since they follow the same pattern.

    Server message (outbound, agent proposes a change):
    ```typescript
    const SoulEvolutionProposeSchema = z.object({
      type: z.literal("soul.evolution.propose"),
      requestId: z.string(),
      file: z.string(),           // e.g., "SOUL.md", "STYLE.md", "IDENTITY.md"
      section: z.string(),        // e.g., "Learned Preferences", "Tone"
      currentContent: z.string(), // existing section content
      proposedContent: z.string(),// proposed replacement
      reason: z.string(),         // why the agent suggests this
    });
    ```

    Client message (inbound, user responds):
    ```typescript
    const SoulEvolutionResponseSchema = z.object({
      type: z.literal("soul.evolution.response"),
      id: z.string(),
      requestId: z.string(),
      approved: z.boolean(),
      editedContent: z.string().optional(), // user may edit before approving
    });
    ```

    Add SoulEvolutionResponseSchema to the ClientMessageSchema discriminated union array.
    Add SoulEvolutionProposeSchema to the ServerMessageSchema discriminated union array.

    Export the inferred types:
    ```typescript
    export type SoulEvolutionPropose = z.infer<typeof SoulEvolutionProposeSchema>;
    export type SoulEvolutionResponse = z.infer<typeof SoulEvolutionResponseSchema>;
    ```
  </action>
  <verify>Run `npx tsc --noEmit` from packages/gateway/. Verify both schemas appear in discriminated unions. Verify types are exported.</verify>
  <done>soul.evolution.propose in ServerMessageSchema, soul.evolution.response in ClientMessageSchema. Types SoulEvolutionPropose and SoulEvolutionResponse exported.</done>
</task>

<task type="auto">
  <name>Task 2: Create evolution handler and identity file section updater</name>
  <files>
    packages/gateway/src/ws/handlers.ts
    packages/gateway/src/ws/server.ts
    packages/db/src/memory/soul-manager.ts
    packages/db/src/memory/index.ts
  </files>
  <action>
    Add `updateIdentityFileSection()` to `packages/db/src/memory/soul-manager.ts`:

    ```typescript
    /**
     * Update a specific section in an identity file.
     * Finds the section by ## header, replaces content between this header and the next.
     * If section not found, appends at end.
     */
    export function updateIdentityFileSection(
      filename: string,
      section: string,
      newContent: string,
    ): void {
      const filePath = join(CONFIG_DIR, "memory", filename);
      if (!existsSync(filePath)) return;

      let content = readFileSync(filePath, "utf-8");
      const sectionHeader = `## ${section}`;
      const headerIndex = content.indexOf(sectionHeader);

      if (headerIndex === -1) {
        // Section not found, append
        content = content.trimEnd() + `\n\n${sectionHeader}\n${newContent}\n`;
      } else {
        // Find end of header line
        const afterHeader = content.indexOf("\n", headerIndex);
        if (afterHeader === -1) return;

        // Find next section
        const remaining = content.slice(afterHeader + 1);
        const nextSectionMatch = remaining.search(/^## /m);

        if (nextSectionMatch !== -1) {
          const insertEnd = afterHeader + 1 + nextSectionMatch;
          content = content.slice(0, afterHeader + 1) + newContent + "\n\n" + content.slice(insertEnd);
        } else {
          content = content.slice(0, afterHeader + 1) + newContent + "\n";
        }
      }

      writeFileSync(filePath, content, "utf-8");
    }
    ```

    Export from index.ts: `export { updateIdentityFileSection } from "./soul-manager.js";`

    Add handler to `packages/gateway/src/ws/handlers.ts`:

    1. Import `SoulEvolutionResponse` type from protocol.
    2. Import `updateIdentityFileSection` from `@tek/db`.
    3. Add handler function:

    ```typescript
    export function handleSoulEvolutionResponse(
      _transport: Transport,
      msg: SoulEvolutionResponse,
      _state: ConnectionState,
    ): void {
      if (!msg.approved) {
        logger.info(`Soul evolution rejected for ${msg.requestId}`);
        return;
      }

      const content = msg.editedContent ?? "";
      if (!content) return;

      // Dynamic import to avoid circular deps
      const { updateIdentityFileSection } = await import("@tek/db");
      // Actually this is sync, so direct import is fine.
      // Use the file and section from a stored pending evolution request
      // For now, store on ConnectionState (similar to pendingApprovals pattern)
      logger.info(`Soul evolution approved for ${msg.requestId}`);
    }
    ```

    Actually, the handler needs to know which file/section to update. The proposal was sent server->client with file+section. When the response comes back, it has requestId. So the handler needs to look up the pending proposal.

    Better approach: Add a `pendingSoulEvolutions` Map to ConnectionState (in connection.ts or handlers.ts):
    - When agent proposes evolution (in agent loop), store `{ file, section, currentContent, proposedContent }` keyed by requestId
    - When response arrives, look up the pending proposal, apply the content

    In handlers.ts, add:
    ```typescript
    /** Pending soul evolution proposals keyed by requestId */
    const pendingSoulEvolutions = new Map<string, { file: string; section: string; proposedContent: string }>();

    /** Per-connection evolution proposal counter for rate limiting (max 1 per session) */
    const evolutionCountByConnection = new Map<string, number>();

    export function registerSoulEvolution(requestId: string, file: string, section: string, proposedContent: string, connectionId: string): void {
      // Rate limit: max 1 evolution proposal per session/connection
      const count = evolutionCountByConnection.get(connectionId) ?? 0;
      if (count >= 1) {
        logger.warn(`Soul evolution rate limit reached for connection ${connectionId} (max 1 per session)`);
        throw new Error("Rate limit: max 1 soul evolution proposal per session");
      }
      evolutionCountByConnection.set(connectionId, count + 1);
      pendingSoulEvolutions.set(requestId, { file, section, proposedContent });
    }

    /** Clean up rate limit counter when connection closes */
    export function clearEvolutionRateLimit(connectionId: string): void {
      evolutionCountByConnection.delete(connectionId);
    }

    export function handleSoulEvolutionResponse(
      _transport: Transport,
      msg: SoulEvolutionResponse,
      _state: ConnectionState,
    ): void {
      const pending = pendingSoulEvolutions.get(msg.requestId);
      if (!pending) {
        logger.warn(`No pending soul evolution for requestId ${msg.requestId}`);
        return;
      }
      pendingSoulEvolutions.delete(msg.requestId);

      if (!msg.approved) {
        logger.info(`Soul evolution rejected for ${pending.file}#${pending.section}`);
        return;
      }

      const content = msg.editedContent ?? pending.proposedContent;
      updateIdentityFileSection(pending.file, pending.section, content);
      logger.info(`Soul evolution applied to ${pending.file}#${pending.section}`);
    }
    ```

    Wire the handler in `packages/gateway/src/ws/server.ts`. The dispatch switch lives at line 102 of that file. Add a new case after the existing `claude-code.abort` case (before the closing `}` of the switch):
    ```typescript
    case "soul.evolution.response": {
      logger.info(`soul.evolution.response for requestId: ${msg.requestId}`);
      handleSoulEvolutionResponse(transport, msg, connState);
      break;
    }
    ```

    Also in server.ts, import `handleSoulEvolutionResponse` and `clearEvolutionRateLimit` from `./handlers.js` (add to the existing named import block at the top of server.ts).

    In the `socket.on("close", ...)` handler in server.ts (currently at line 359), add a call to clean up the rate limit state:
    ```typescript
    socket.on("close", () => {
      logger.info("WebSocket client disconnected");
      clearEvolutionRateLimit(transport.transportId);
      removeConnection(transport.transportId);
    });
    ```
    Do the same in `socket.on("error", ...)` before `removeConnection`.

    Import `updateIdentityFileSection` at the top of handlers.ts from `@tek/db`.
  </action>
  <verify>Run `npx tsc --noEmit` from packages/gateway/ and packages/db/. Verify with `grep "soul.evolution.response" packages/gateway/src/ws/server.ts` that the case is in the switch. Verify `grep "clearEvolutionRateLimit" packages/gateway/src/ws/server.ts` shows calls in both close and error handlers. Verify updateIdentityFileSection is exported from @tek/db. Verify registerSoulEvolution throws when count >= 1 for the same connectionId.</verify>
  <done>soul.evolution.response case in server.ts switch dispatches to handleSoulEvolutionResponse. Handler looks up pending proposal by requestId, writes approved content to the target identity file section via updateIdentityFileSection. registerSoulEvolution() available for agent loop to register proposals with per-connection rate limit (max 1 per session). clearEvolutionRateLimit() called in connection close and error handlers in server.ts. updateIdentityFileSection exported from @tek/db.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes from both packages/gateway/ and packages/db/
- `grep "soul.evolution" packages/gateway/src/ws/protocol.ts` shows both propose and response schemas
- `grep "handleSoulEvolutionResponse" packages/gateway/src/ws/handlers.ts` shows handler
- `grep "soul.evolution.response" packages/gateway/src/ws/server.ts` shows case in switch dispatch
- `grep "clearEvolutionRateLimit" packages/gateway/src/ws/server.ts` shows calls in close and error handlers
- `grep "updateIdentityFileSection" packages/db/src/memory/soul-manager.ts` shows function
- `grep "updateIdentityFileSection" packages/db/src/memory/index.ts` shows export
</verification>

<success_criteria>
- Protocol has soul.evolution.propose (server) and soul.evolution.response (client) schemas
- Both schemas in their respective discriminated unions
- Handler looks up pending proposals and writes approved content
- updateIdentityFileSection can update any section in any identity file
- registerSoulEvolution allows agent loop to register proposals
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/16-agent-personality-system/16-04-SUMMARY.md`
</output>
