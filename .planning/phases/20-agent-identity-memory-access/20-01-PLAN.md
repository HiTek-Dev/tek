---
phase: 20-agent-identity-memory-access
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/gateway/src/tools/memory.ts
  - packages/gateway/src/agent/tool-registry.ts
autonomous: true
requirements:
  - P20-IDENTITY
  - P20-MEMORY
  - P20-DAILYLOG
  - P20-INIT

must_haves:
  truths:
    - "Agent can read its own identity files (SOUL.md, IDENTITY.md, STYLE.md, USER.md) during chat via memory_read tool"
    - "Agent can write to MEMORY.md sections and daily log files during chat via memory_write tool"
    - "Memory tools bypass workspace restrictions but only access ~/.config/tek/memory/ paths"
    - "Memory read is auto-approved; memory write requires session-level approval"
  artifacts:
    - path: "packages/gateway/src/tools/memory.ts"
      provides: "Memory read and write tool definitions"
      exports: ["createMemoryReadTool", "createMemoryWriteTool"]
    - path: "packages/gateway/src/agent/tool-registry.ts"
      provides: "Tool registry with memory tools registered"
      contains: "memory_read"
  key_links:
    - from: "packages/gateway/src/tools/memory.ts"
      to: "@tek/db memory functions"
      via: "import { loadSoul, loadIdentity, loadStyle, loadUser, loadLongTermMemory, loadRecentLogs, addMemoryEntry, appendDailyLog, updateIdentityFileSection }"
      pattern: "from \"@tek/db\""
    - from: "packages/gateway/src/agent/tool-registry.ts"
      to: "packages/gateway/src/tools/memory.ts"
      via: "import and register memory tools"
      pattern: "createMemoryReadTool|createMemoryWriteTool"
---

<objective>
Create memory read/write tools that let the agent access its own identity and memory files during chat, and register them in the tool registry.

Purpose: The agent currently has no way to read or write its own identity/memory files during a chat session. These tools enable self-awareness (reading SOUL.md, USER.md) and memory persistence (writing to MEMORY.md, daily logs).

Output: New `packages/gateway/src/tools/memory.ts` with two tool definitions, and updated tool registry that registers them on every chat connection.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-agent-identity-memory-access/20-RESEARCH.md
@packages/gateway/src/agent/tool-registry.ts
@packages/gateway/src/tools/filesystem.ts
@packages/db/src/memory/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create memory read/write tools</name>
  <files>packages/gateway/src/tools/memory.ts</files>
  <action>
Create `packages/gateway/src/tools/memory.ts` with two exported factory functions:

1. `createMemoryReadTool(agentId?: string)` — Returns a Vercel AI SDK `tool()` that reads identity/memory files.
   - inputSchema: `{ file: z.enum(["SOUL.md", "IDENTITY.md", "STYLE.md", "USER.md", "MEMORY.md", "DAILY_LOGS"]) }`
   - description: "Read one of your identity or memory files. Available files: SOUL.md (your personality), IDENTITY.md (your traits), STYLE.md (communication style), USER.md (user context), MEMORY.md (long-term memory), DAILY_LOGS (recent daily logs)"
   - execute: Switch on file param, call the appropriate `@tek/db` function:
     - SOUL.md → `loadSoul(agentId)`
     - IDENTITY.md → `loadIdentity(agentId)`
     - STYLE.md → `loadStyle(agentId)`
     - USER.md → `loadUser()` (always global)
     - MEMORY.md → `loadLongTermMemory()`
     - DAILY_LOGS → `loadRecentLogs()`
   - Return the content or "(empty)" if falsy

2. `createMemoryWriteTool()` — Returns a Vercel AI SDK `tool()` that writes to memory/identity files.
   - inputSchema: `{ target: z.enum(["memory", "daily", "identity"]), content: z.string(), section: z.string().optional(), file: z.string().optional() }`
   - description: "Write to your memory or identity files. Use 'memory' to add facts to MEMORY.md, 'daily' to append to today's log, 'identity' to update a section in an identity file."
   - execute: Switch on target:
     - "memory": Validate section is one of "User Facts" | "Project Context" | "Preferences" | "Important Decisions", call `addMemoryEntry(section, content)`. Default section to "User Facts".
     - "daily": Call `appendDailyLog(content)`.
     - "identity": Validate file is one of SOUL.md/IDENTITY.md/STYLE.md/USER.md, call `updateIdentityFileSection(file, section, content)`. Default file to "SOUL.md", section to "Learned Preferences".
   - Return confirmation string on success, error string on invalid input.

Use `import { tool } from "ai"` and `import { z } from "zod"` consistent with existing tool patterns in `packages/gateway/src/tools/skill.ts`.
Import all memory functions from `@tek/db`.
Import `MemorySection` type from `@tek/db`.
  </action>
  <verify>
Run `cd /Users/hitekmedia/Documents/GitHub/tek && npx tsc --noEmit -p packages/gateway/tsconfig.json 2>&1 | head -30` — no errors related to memory.ts.
  </verify>
  <done>
`packages/gateway/src/tools/memory.ts` exports `createMemoryReadTool` and `createMemoryWriteTool`, both returning AI SDK tool definitions that wrap @tek/db functions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register memory tools in tool registry</name>
  <files>packages/gateway/src/agent/tool-registry.ts</files>
  <action>
Update `packages/gateway/src/agent/tool-registry.ts` to register the memory tools:

1. Add import at top: `import { createMemoryReadTool, createMemoryWriteTool } from "../tools/memory.js";`
2. Add import: `import { loadConfig } from "@tek/core";` (already imported via other paths — check if needed or already available)

3. After the Google Workspace tools section (step 6, before the final logger.info), add step 7:

```typescript
// 7. Add memory tools (always available, bypasses workspace restrictions)
const agentConfig = loadConfig();
const currentAgentId = agentConfig?.agents?.defaultAgentId;
const memoryRead = createMemoryReadTool(currentAgentId === "default" ? undefined : currentAgentId);
const memoryWrite = createMemoryWriteTool();

tools.memory_read = approvalPolicy
  ? wrapToolWithApproval("memory_read", memoryRead as unknown as Record<string, unknown>, approvalPolicy)
  : memoryRead;
tools.memory_write = approvalPolicy
  ? wrapToolWithApproval("memory_write", memoryWrite as unknown as Record<string, unknown>, approvalPolicy)
  : memoryWrite;

// Memory read is safe (auto tier), memory write needs session approval
if (approvalPolicy) {
  approvalPolicy.perTool.memory_read = "auto";
  approvalPolicy.perTool.memory_write = "session";
}
```

Note: `loadConfig` may already be available in scope from tool-registry.ts context. Check if it's imported. If not, import it from `@tek/core`. The config is also loaded inside the handler in handlers.ts, but tool-registry needs its own call since it receives options, not config directly.
  </action>
  <verify>
Run `cd /Users/hitekmedia/Documents/GitHub/tek && npx tsc --noEmit -p packages/gateway/tsconfig.json 2>&1 | head -30` — no errors. Also verify `grep -n "memory_read\|memory_write\|createMemoryReadTool" packages/gateway/src/agent/tool-registry.ts` shows the registrations.
  </verify>
  <done>
Tool registry registers `memory_read` (auto approval) and `memory_write` (session approval) tools on every chat connection, giving the agent self-access to its identity and memory files.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit -p packages/gateway/tsconfig.json` passes without errors
2. `memory.ts` exports both factory functions
3. `tool-registry.ts` imports and registers both memory tools
4. Approval tiers set correctly: memory_read=auto, memory_write=session
</verification>

<success_criteria>
- Agent has memory_read and memory_write tools available in every chat session
- memory_read can read all 6 identity/memory file types (SOUL.md, IDENTITY.md, STYLE.md, USER.md, MEMORY.md, DAILY_LOGS)
- memory_write can write to MEMORY.md sections, daily logs, and identity file sections
- Tools bypass workspace restrictions (they use @tek/db functions that access ~/.config/tek/memory/ directly)
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/20-agent-identity-memory-access/20-01-SUMMARY.md`
</output>
