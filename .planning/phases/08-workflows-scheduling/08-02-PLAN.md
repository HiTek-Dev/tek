---
phase: 08-workflows-scheduling
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - packages/gateway/src/workflow/loader.ts
  - packages/gateway/src/workflow/executor.ts
  - packages/gateway/src/workflow/state.ts
  - packages/gateway/src/workflow/engine.ts
  - packages/gateway/src/workflow/templates.ts
  - packages/gateway/src/workflow/index.ts
autonomous: true

must_haves:
  truths:
    - "YAML workflow definitions can be loaded from disk and validated against the schema"
    - "TypeScript workflow definitions (.workflow.ts) can be loaded via dynamic import"
    - "Workflow steps execute sequentially with pass/fail/decision branching"
    - "Step results are chained via {{steps.stepId.result}} template syntax"
    - "Workflow execution state persists to SQLite after every step transition"
    - "Workflows pause at approval gates and can resume after approval"
  artifacts:
    - path: "packages/gateway/src/workflow/loader.ts"
      provides: "loadWorkflowDefinition, discoverWorkflows"
      exports: ["loadWorkflowDefinition", "discoverWorkflows"]
    - path: "packages/gateway/src/workflow/executor.ts"
      provides: "StepExecutor with tool/model/noop step execution and branching"
      exports: ["executeStep", "resolveNextStep"]
    - path: "packages/gateway/src/workflow/state.ts"
      provides: "WorkflowState persistence to SQLite"
      exports: ["saveExecution", "loadExecution", "listExecutions"]
    - path: "packages/gateway/src/workflow/engine.ts"
      provides: "WorkflowEngine orchestrating load, execute, resume"
      exports: ["WorkflowEngine"]
    - path: "packages/gateway/src/workflow/templates.ts"
      provides: "resolveTemplates for {{}} syntax"
      exports: ["resolveTemplates"]
  key_links:
    - from: "packages/gateway/src/workflow/engine.ts"
      to: "packages/gateway/src/workflow/executor.ts"
      via: "executeStep call in run loop"
      pattern: "executeStep"
    - from: "packages/gateway/src/workflow/engine.ts"
      to: "packages/gateway/src/workflow/state.ts"
      via: "saveExecution after each step"
      pattern: "saveExecution"
    - from: "packages/gateway/src/workflow/executor.ts"
      to: "packages/gateway/src/workflow/templates.ts"
      via: "resolveTemplates for prompt/args"
      pattern: "resolveTemplates"
---

<objective>
Build the workflow engine: load definitions from YAML/TS files, execute steps with branching logic, persist execution state to SQLite for durability, and handle approval gate pauses.

Purpose: This is the core orchestration engine that powers multi-step workflows with pass/fail/decision branching (WKFL-01, WKFL-02, WKFL-03, WKFL-04).
Output: WorkflowEngine class with load, execute, resume capabilities.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-workflows-scheduling/08-RESEARCH.md
@.planning/phases/08-workflows-scheduling/08-01-SUMMARY.md

@packages/gateway/src/workflow/types.ts
@packages/gateway/src/workflow/index.ts
@packages/db/src/schema/workflows.ts
@packages/gateway/src/agent/tool-loop.ts
@packages/gateway/src/agent/approval-gate.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Template resolver, workflow loader, and state persistence</name>
  <files>
    packages/gateway/src/workflow/templates.ts
    packages/gateway/src/workflow/loader.ts
    packages/gateway/src/workflow/state.ts
  </files>
  <action>
1. Create `packages/gateway/src/workflow/templates.ts`:
   - `resolveTemplates(template: string, context: { steps: Record<string, { output: unknown; status: string }>; error?: string }): string`
   - Replace `{{steps.stepId.result}}` or `{{steps.stepId.output}}` with stringified step output
   - Replace `{{steps | json}}` with JSON.stringify of all step results
   - Replace `{{error}}` with context error or "No error"
   - Use regex `/\{\{(.+?)\}\}/g` for matching
   - IMPORTANT: Only resolve templates in prompt and args fields (step definition), never in step result outputs (prevents template injection per research pitfall 5)

2. Create `packages/gateway/src/workflow/loader.ts`:
   - `import { parse } from "yaml";` for YAML parsing
   - `loadWorkflowDefinition(filePath: string): Promise<WorkflowDefinition>`:
     - If `.yaml` or `.yml`: read file, parse YAML, validate with WorkflowDefinitionSchema.parse()
     - If `.ts` or `.workflow.ts`: dynamic import via `import(filePath)`, access `.default`, validate
     - Throw descriptive error for invalid definitions
   - `discoverWorkflows(dirs: string[]): Promise<Array<{ name: string; path: string; definition: WorkflowDefinition }>>`:
     - Scan directories for `*.yaml`, `*.yml`, `*.workflow.ts` files
     - Use readdirSync (matching Phase 6 pattern for flat directory scanning)
     - Load and validate each, skip invalid files silently (safeParse pattern from 06-02)
     - Return array of discovered workflows sorted by name

3. Create `packages/gateway/src/workflow/state.ts`:
   - Uses `getDb()` from `@agentspace/db` and the workflows/workflowExecutions tables
   - `saveExecution(execution: WorkflowExecutionState): void` — upsert into workflowExecutions (sync, matching better-sqlite3 pattern). Serialize stepResults as JSON string.
   - `loadExecution(executionId: string): WorkflowExecutionState | null` — load from DB, parse stepResults JSON
   - `listExecutions(workflowId?: string, status?: string): WorkflowExecutionState[]` — list executions with optional filters
   - `registerWorkflow(id: string, name: string, description: string | undefined, definitionPath: string): void` — insert/update workflows table
   - All functions sync (matching existing store pattern with Drizzle + better-sqlite3)
  </action>
  <verify>
`pnpm --filter @agentspace/gateway exec tsc --noEmit` passes.
  </verify>
  <done>Template resolver handles {{steps.X.result}}, {{steps | json}}, {{error}}. Loader can parse YAML and TS workflow files. State persistence saves/loads executions to/from SQLite.</done>
</task>

<task type="auto">
  <name>Task 2: Step executor, workflow engine, and barrel exports</name>
  <files>
    packages/gateway/src/workflow/executor.ts
    packages/gateway/src/workflow/engine.ts
    packages/gateway/src/workflow/index.ts
  </files>
  <action>
1. Create `packages/gateway/src/workflow/executor.ts`:
   - `evaluateCondition(condition: string, result: unknown): boolean`:
     - Use `new Function("result", '"use strict"; return (' + condition + ");")` to create evaluator
     - Wrap in try/catch, return false on error
     - Only `result` variable is accessible (restricted scope per research)
   - `resolveNextStep(step: StepDefinition, result: { status: string; output: unknown }, steps: StepDefinition[]): string | null`:
     - Check branches array first: iterate, evaluateCondition against result.output, return branch.goto on first match
     - Then check onSuccess/onFailure based on result.status
     - Fall back to null (engine advances to next step by array index)
   - `executeStep(step: StepDefinition, context: { steps: Record<string, StepResult>; tools: Record<string, unknown>; error?: string }): Promise<StepResult>`:
     - Switch on step.action:
       - `"tool"`: Resolve templates in step.args, call the tool from context.tools by step.tool name. Use the tool's execute function directly. Wrap result as StepResult { status: "success", output, completedAt }.
       - `"model"`: Resolve templates in step.prompt, call generateText from AI SDK with resolved prompt. Parse output. Return as StepResult.
       - `"noop"`: Return { status: "success", output: null, completedAt }
     - On error: return { status: "failure", output: error.message, completedAt }
     - Apply step.timeout if set (use AbortController with setTimeout)

2. Create `packages/gateway/src/workflow/engine.ts`:
   - `class WorkflowEngine`:
     - Constructor takes no args; uses lazy-init pattern
     - `async execute(workflowId: string, definitionPath: string, triggeredBy: "manual" | "cron" | "heartbeat", tools: Record<string, unknown>, onApprovalNeeded?: (executionId: string, stepId: string, step: StepDefinition) => void): Promise<WorkflowExecutionState>`:
       - Load definition via loader
       - Create execution state: { id: nanoid(), workflowId, status: "running", stepResults: {}, startedAt: new Date().toISOString(), triggeredBy }
       - Save initial state
       - Call `runSteps()` internal method
     - `async resume(executionId: string, tools: Record<string, unknown>, onApprovalNeeded?: (...) => void): Promise<WorkflowExecutionState>`:
       - Load execution state from DB
       - If not paused, throw error
       - Mark step that was paused as approved, set status back to "running"
       - Continue from the step after the paused one
       - Call `runSteps()` to continue
     - Private `async runSteps(execution: WorkflowExecutionState, definition: WorkflowDefinition, tools: Record<string, unknown>, onApprovalNeeded?: (...) => void)`:
       - Find starting step (currentStepId or first step)
       - Loop: for each step:
         - If step.approvalRequired and not already approved: set status="paused", save state, call onApprovalNeeded callback, return
         - Execute step via executor.executeStep()
         - Store result in execution.stepResults[step.id]
         - Save execution state to DB (durable execution: persist after EVERY step)
         - Resolve next step via resolveNextStep()
         - If null and at end of steps array: mark completed
         - If resolved to a step id: find that step and continue
       - On error: set status="failed", save, return
   - Export singleton: `export const workflowEngine = new WorkflowEngine();`

3. Update `packages/gateway/src/workflow/index.ts` barrel:
   - Export from types.ts, loader.ts, executor.ts, state.ts, engine.ts
  </action>
  <verify>
`pnpm --filter @agentspace/gateway exec tsc --noEmit` passes.
Grep for "class WorkflowEngine" in engine.ts confirms the engine exists.
Grep for "evaluateCondition" in executor.ts confirms branching logic exists.
  </verify>
  <done>WorkflowEngine can load YAML/TS definitions, execute steps sequentially with branching (pass/fail/decision), chain results via templates, persist state after each step, and pause at approval gates.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @agentspace/gateway exec tsc --noEmit` — all new files compile
2. WorkflowEngine exports from workflow/index.ts
3. Template resolution handles {{steps.X.result}}, {{steps | json}}, {{error}}
4. Condition evaluation via new Function with restricted scope
5. State persistence saves after every step transition
</verification>

<success_criteria>
- YAML and TypeScript workflow definitions load and validate
- Steps execute with tool, model, and noop action types
- Branch conditions evaluate against step results
- Step results chain via {{steps.stepId.result}} templates
- Execution state persists to SQLite after every step
- Approval gates pause execution and support resume
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-scheduling/08-02-SUMMARY.md`
</output>
