---
phase: 08-workflows-scheduling
plan: 03
type: execute
wave: 3
depends_on: ["08-01", "08-02"]
files_modified:
  - packages/gateway/src/scheduler/scheduler.ts
  - packages/gateway/src/scheduler/heartbeat.ts
  - packages/gateway/src/scheduler/store.ts
  - packages/gateway/src/scheduler/index.ts
autonomous: true

must_haves:
  truths:
    - "Cron schedules can be created, paused, resumed, and stopped"
    - "Active hours guard prevents execution outside configured time windows"
    - "Schedules persist in SQLite and reload on startup"
    - "Heartbeat reads HEARTBEAT.md checklist, runs agent checks, and only alerts when action is needed"
    - "One-shot schedules run once and stop (maxRuns=1)"
    - "Overlapping heartbeat runs are prevented via Croner protect option"
  artifacts:
    - path: "packages/gateway/src/scheduler/scheduler.ts"
      provides: "CronScheduler with schedule/pause/resume/stop/reload lifecycle"
      exports: ["CronScheduler", "cronScheduler"]
    - path: "packages/gateway/src/scheduler/heartbeat.ts"
      provides: "HeartbeatRunner reading HEARTBEAT.md and executing checks"
      exports: ["HeartbeatRunner"]
    - path: "packages/gateway/src/scheduler/store.ts"
      provides: "Schedule CRUD persistence in SQLite"
      exports: ["saveSchedule", "loadSchedules", "updateSchedule", "deleteSchedule"]
  key_links:
    - from: "packages/gateway/src/scheduler/scheduler.ts"
      to: "packages/gateway/src/scheduler/store.ts"
      via: "loadSchedules on startup, saveSchedule on create"
      pattern: "loadSchedules|saveSchedule"
    - from: "packages/gateway/src/scheduler/scheduler.ts"
      to: "packages/gateway/src/workflow/engine.ts"
      via: "workflowEngine.execute on cron trigger"
      pattern: "workflowEngine\\.execute"
    - from: "packages/gateway/src/scheduler/heartbeat.ts"
      to: "packages/gateway/src/scheduler/scheduler.ts"
      via: "registers heartbeat as a cron job"
      pattern: "schedule"
---

<objective>
Build the cron scheduler and heartbeat monitoring system. The scheduler manages Croner jobs with active hours filtering and SQLite persistence. The heartbeat reads HEARTBEAT.md checklists and runs agent-powered checks that only alert when action is needed.

Purpose: Enables cron-based task scheduling (WKFL-08), heartbeat monitoring (WKFL-05/06), and active hours (WKFL-07).
Output: CronScheduler singleton, HeartbeatRunner, schedule persistence layer.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-workflows-scheduling/08-RESEARCH.md
@.planning/phases/08-workflows-scheduling/08-01-SUMMARY.md
@.planning/phases/08-workflows-scheduling/08-02-SUMMARY.md

@packages/gateway/src/workflow/engine.ts
@packages/gateway/src/workflow/types.ts
@packages/gateway/src/scheduler/types.ts
@packages/db/src/schema/schedules.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Schedule store and heartbeat runner</name>
  <files>
    packages/gateway/src/scheduler/store.ts
    packages/gateway/src/scheduler/heartbeat.ts
  </files>
  <action>
1. Create `packages/gateway/src/scheduler/store.ts`:
   - Uses `getDb()` from `@agentspace/db` and the schedules table
   - `saveSchedule(config: ScheduleConfig): void` — insert into schedules table, mapping ScheduleConfig fields to DB columns. Store activeHours.daysOfWeek as JSON string. Sync function (Drizzle + better-sqlite3 pattern).
   - `loadSchedules(enabledOnly?: boolean): ScheduleConfig[]` — query schedules, optionally filtering `WHERE enabled = true`. Map DB rows back to ScheduleConfig objects (parse activeHoursDays JSON).
   - `updateSchedule(id: string, updates: Partial<Pick<ScheduleConfig, "cronExpression" | "timezone" | "activeHours" | "maxRuns" | "enabled">>): void` — partial update with updatedAt timestamp
   - `deleteSchedule(id: string): void` — delete from schedules table
   - `getSchedule(id: string): ScheduleConfig | null` — load single schedule by ID

2. Create `packages/gateway/src/scheduler/heartbeat.ts`:
   - `import matter from "gray-matter";` for HEARTBEAT.md parsing (already in core deps)
   - `loadHeartbeatConfig(heartbeatPath: string): { config: HeartbeatConfig; checklistItems: string[] }`:
     - Read file with readFileSync
     - Parse with gray-matter to extract frontmatter and content
     - Validate frontmatter with HeartbeatConfigSchema.parse()
     - Extract checklist items: lines matching `/^\s*-\s*\[[ x]\]\s+/`, strip prefix, trim
     - Return config and items
   - `class HeartbeatRunner`:
     - Constructor takes `heartbeatPath: string`
     - `async run(tools: Record<string, unknown>): Promise<Array<{ description: string; actionNeeded: boolean; details?: string }>>`:
       - Load config and checklist via loadHeartbeatConfig
       - For each checklist item, run sequentially (not parallel — per research anti-pattern):
         - Use generateText from AI SDK with system prompt: "You are a monitoring agent. Check the following item and determine if any action is needed. Respond with JSON: {\"actionNeeded\": boolean, \"details\": \"brief explanation\"}. Only set actionNeeded to true if the user MUST take action."
         - User prompt: "Check: {item}\nUse the available tools to verify this."
         - Pass tools, set maxSteps to 5
         - Parse the agent's text response as JSON
         - On parse error: { actionNeeded: false, details: "Check could not be evaluated" }
       - Return only results (filter: return ALL results, let the caller decide whether to alert)
     - `getConfig(): { config: HeartbeatConfig; checklistItems: string[] }`:
       - Reload and return current config (allows hot-reload of HEARTBEAT.md)
  </action>
  <verify>
`pnpm --filter @agentspace/gateway exec tsc --noEmit` passes.
  </verify>
  <done>Schedule store persists configs to SQLite with CRUD operations. HeartbeatRunner loads HEARTBEAT.md, executes agent-powered checks sequentially, and returns structured results with actionNeeded flags.</done>
</task>

<task type="auto">
  <name>Task 2: Cron scheduler with active hours and lifecycle management</name>
  <files>
    packages/gateway/src/scheduler/scheduler.ts
    packages/gateway/src/scheduler/index.ts
  </files>
  <action>
1. Create `packages/gateway/src/scheduler/scheduler.ts`:
   - `import { Cron } from "croner";`
   - `isWithinActiveHours(hours: ActiveHours): boolean`:
     - Get current date/time
     - Check daysOfWeek if defined (convert JS Sunday=0 to ISO Monday=1..Sunday=7)
     - Parse start/end as HH:MM, compare against current time in minutes
     - Return true if within window
   - `class CronScheduler`:
     - Private `jobs = new Map<string, Cron>()`
     - `schedule(config: ScheduleConfig, handler: () => Promise<void>): void`:
       - Create Croner job with config.cronExpression, timezone, maxRuns, paused (!config.enabled), name (config.id)
       - Set catch handler that logs errors via createLogger("cron-scheduler")
       - In the job callback: check activeHours guard (skip with log if outside window), then call handler()
       - Store in jobs map
     - `scheduleWorkflow(config: ScheduleConfig, tools: Record<string, unknown>): void`:
       - Call schedule() with a handler that calls workflowEngine.execute(config.workflowId, ...)
       - Only if config.workflowId is set
     - `scheduleHeartbeat(config: ScheduleConfig, heartbeatPath: string, tools: Record<string, unknown>, onAlert: (results: Array<{ description: string; actionNeeded: boolean; details?: string }>) => void): void`:
       - Create HeartbeatRunner
       - Call schedule() with handler that runs heartbeat, filters for actionNeeded items, calls onAlert if any
       - Use Croner's `protect: true` option to prevent overlapping runs
     - `pause(id: string): void` — pause job
     - `resume(id: string): void` — resume job
     - `stop(id: string): void` — stop and delete job
     - `stopAll(): void` — stop all jobs, clear map
     - `nextRun(id: string): Date | null` — return next scheduled run
     - `listActive(): Array<{ id: string; nextRun: Date | null }>` — list all active job IDs with next run times
     - `async reload(tools: Record<string, unknown>, heartbeatPath?: string, onAlert?: (...) => void): Promise<void>`:
       - Stop all existing jobs
       - Load enabled schedules from store
       - Re-create Croner jobs for each
       - If heartbeatPath provided, also schedule heartbeat
   - Export singleton: `export const cronScheduler = new CronScheduler();`

2. Update `packages/gateway/src/scheduler/index.ts` barrel:
   - Export from types.ts, store.ts, heartbeat.ts, scheduler.ts
  </action>
  <verify>
`pnpm --filter @agentspace/gateway exec tsc --noEmit` passes.
Grep for "class CronScheduler" in scheduler.ts confirms it exists.
Grep for "isWithinActiveHours" confirms active hours guard.
Grep for "protect: true" confirms overlap prevention for heartbeat.
  </verify>
  <done>CronScheduler manages Croner jobs with active hours filtering, persist/reload from SQLite, heartbeat scheduling with overlap prevention, and full lifecycle (schedule/pause/resume/stop/reload).</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @agentspace/gateway exec tsc --noEmit` — all new files compile
2. CronScheduler and HeartbeatRunner export from scheduler/index.ts
3. Active hours guard function exists and checks day-of-week + time window
4. Croner protect option prevents overlapping heartbeat runs
5. Schedule store persists to SQLite with CRUD operations
</verification>

<success_criteria>
- Cron schedules create, pause, resume, stop correctly
- Active hours prevent execution outside configured windows
- One-shot schedules supported via maxRuns=1
- Heartbeat reads HEARTBEAT.md with gray-matter frontmatter
- Heartbeat runs checks sequentially and flags actionNeeded items
- Overlapping heartbeat runs prevented
- Schedules persist and reload from SQLite
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-scheduling/08-03-SUMMARY.md`
</output>
