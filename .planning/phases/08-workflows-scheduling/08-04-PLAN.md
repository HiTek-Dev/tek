---
phase: 08-workflows-scheduling
plan: 04
type: execute
wave: 4
depends_on: ["08-02", "08-03"]
files_modified:
  - packages/gateway/src/ws/protocol.ts
  - packages/gateway/src/ws/handlers.ts
  - packages/gateway/src/ws/server.ts
  - packages/gateway/src/ws/connection.ts
autonomous: true

must_haves:
  truths:
    - "Clients can trigger workflows via WebSocket and receive execution status updates"
    - "Clients can approve or deny workflow approval gates via WebSocket"
    - "Clients can create, update, list, and manage cron schedules via WebSocket"
    - "Clients can configure heartbeat monitoring via WebSocket and receive alerts"
    - "Workflow and schedule protocol messages validate with Zod schemas"
  artifacts:
    - path: "packages/gateway/src/ws/protocol.ts"
      provides: "Zod schemas for workflow.*, schedule.*, heartbeat.* client and server messages"
      contains: "workflow.trigger"
    - path: "packages/gateway/src/ws/handlers.ts"
      provides: "Handler functions for workflow, schedule, and heartbeat messages"
      exports: ["handleWorkflowTrigger", "handleWorkflowApproval", "handleScheduleCreate"]
    - path: "packages/gateway/src/ws/server.ts"
      provides: "Switch cases wiring new message types to handlers"
      contains: "workflow.trigger"
  key_links:
    - from: "packages/gateway/src/ws/handlers.ts"
      to: "packages/gateway/src/workflow/engine.ts"
      via: "workflowEngine.execute in handleWorkflowTrigger"
      pattern: "workflowEngine"
    - from: "packages/gateway/src/ws/handlers.ts"
      to: "packages/gateway/src/scheduler/scheduler.ts"
      via: "cronScheduler in handleScheduleCreate"
      pattern: "cronScheduler"
    - from: "packages/gateway/src/ws/server.ts"
      to: "packages/gateway/src/ws/handlers.ts"
      via: "handler dispatch in switch statement"
      pattern: "handleWorkflow|handleSchedule|handleHeartbeat"
---

<objective>
Wire the workflow engine and scheduler into the WebSocket protocol. Add client/server message schemas for workflow triggering, approval, scheduling CRUD, and heartbeat configuration. Wire handlers in server.ts.

Purpose: Enables clients (CLI, future Telegram) to trigger workflows, manage schedules, and receive heartbeat alerts through the established WebSocket protocol (all WKFL requirements).
Output: Complete WebSocket protocol integration for all Phase 8 features.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-workflows-scheduling/08-RESEARCH.md
@.planning/phases/08-workflows-scheduling/08-02-SUMMARY.md
@.planning/phases/08-workflows-scheduling/08-03-SUMMARY.md

@packages/gateway/src/ws/protocol.ts
@packages/gateway/src/ws/handlers.ts
@packages/gateway/src/ws/server.ts
@packages/gateway/src/ws/connection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add workflow/schedule/heartbeat protocol schemas</name>
  <files>
    packages/gateway/src/ws/protocol.ts
    packages/gateway/src/ws/connection.ts
  </files>
  <action>
1. Add new CLIENT message schemas to `packages/gateway/src/ws/protocol.ts` (before the ClientMessageSchema union):

   - `WorkflowTriggerSchema`: type "workflow.trigger", id (string), workflowId (string), input (z.record(z.string(), z.unknown()) optional)
   - `WorkflowApprovalSchema`: type "workflow.approval", id (string), executionId (string), stepId (string), approved (boolean)
   - `WorkflowListSchema`: type "workflow.list", id (string)
   - `WorkflowExecutionListSchema`: type "workflow.execution.list", id (string), workflowId (string optional), status (string optional)
   - `ScheduleCreateSchema`: type "schedule.create", id (string), name (string), cronExpression (string), timezone (string optional), workflowId (string optional), activeHours (z.object with start/end strings, daysOfWeek z.array(z.number()) optional) optional, maxRuns (number optional)
   - `ScheduleUpdateSchema`: type "schedule.update", id (string), scheduleId (string), enabled (boolean optional), cronExpression (string optional), activeHours (same shape) optional
   - `ScheduleDeleteSchema`: type "schedule.delete", id (string), scheduleId (string)
   - `ScheduleListSchema`: type "schedule.list", id (string)
   - `HeartbeatConfigureSchema`: type "heartbeat.configure", id (string), interval (number default 30), timezone (string optional), activeHours (same shape) optional, enabled (boolean default true)

2. Add all 9 new schemas to the ClientMessageSchema discriminated union array.

3. Add new SERVER message schemas (before the ServerMessageSchema union):

   - `WorkflowStatusSchema`: type "workflow.status", executionId (string), workflowId (string), status (enum "running"|"paused"|"completed"|"failed"), currentStepId (string optional), stepResults (z.record(z.string(), z.unknown()) optional)
   - `WorkflowApprovalRequestSchema`: type "workflow.approval.request", executionId (string), workflowId (string), stepId (string), stepDescription (string), args (z.unknown() optional)
   - `WorkflowListResultSchema`: type "workflow.list.result", id (string), workflows (array of {id, name, description optional, definitionPath})
   - `WorkflowExecutionListResultSchema`: type "workflow.execution.list.result", id (string), executions (array of {id, workflowId, status, currentStepId optional, startedAt, completedAt optional})
   - `ScheduleListResultSchema`: type "schedule.list.result", id (string), schedules (array of {id, name, cronExpression, timezone optional, enabled, nextRun string optional, workflowId optional})
   - `ScheduleCreatedSchema`: type "schedule.created", id (string), scheduleId (string)
   - `ScheduleUpdatedSchema`: type "schedule.updated", id (string), scheduleId (string)
   - `HeartbeatAlertSchema`: type "heartbeat.alert", checks (array of {description, actionNeeded boolean, details optional}), timestamp (string)
   - `HeartbeatConfiguredSchema`: type "heartbeat.configured", id (string), scheduleId (string)

4. Add all 9 server schemas to the ServerMessageSchema discriminated union array.

5. Export all new types (inferred from schemas) following the existing pattern.

6. Update `packages/gateway/src/ws/connection.ts`:
   - Add `pendingWorkflowApprovals: Map<string, { executionId: string; resolve: (approved: boolean) => void }>` to ConnectionState interface and initConnection defaults (new Map())
  </action>
  <verify>
`pnpm --filter @agentspace/gateway exec tsc --noEmit` passes.
Grep for "workflow.trigger" in protocol.ts confirms the schema exists.
Count of schemas in ClientMessageSchema union includes the 9 new entries.
  </verify>
  <done>All workflow, schedule, and heartbeat WebSocket protocol messages are defined with Zod schemas, added to discriminated unions, and types are exported. ConnectionState extended for workflow approvals.</done>
</task>

<task type="auto">
  <name>Task 2: Wire handlers and server dispatch for workflow/schedule/heartbeat</name>
  <files>
    packages/gateway/src/ws/handlers.ts
    packages/gateway/src/ws/server.ts
  </files>
  <action>
1. Add handler functions to `packages/gateway/src/ws/handlers.ts`:

   Import types for all 9 new client message types. Import workflowEngine, cronScheduler, and schedule store functions.

   - `handleWorkflowTrigger(ws, msg, connState)`:
     - Look up workflow in DB (via state.ts). If not found, send error.
     - Call workflowEngine.execute() with triggeredBy: "manual", tools from connState
     - Pass onApprovalNeeded callback that sends workflow.approval.request server message and stores in connState.pendingWorkflowApprovals
     - Send workflow.status updates as execution progresses

   - `handleWorkflowApproval(ws, msg, connState)`:
     - Look up pending approval in connState.pendingWorkflowApprovals
     - Resolve the promise with msg.approved
     - If approved: workflowEngine.resume() the execution
     - Send updated workflow.status

   - `handleWorkflowList(ws, msg)`:
     - Query workflows table for all registered workflows
     - Send workflow.list.result

   - `handleWorkflowExecutionList(ws, msg)`:
     - Query workflow_executions with optional workflowId/status filters
     - Send workflow.execution.list.result

   - `handleScheduleCreate(ws, msg)`:
     - Build ScheduleConfig from msg fields (generate id with nanoid)
     - Save to DB via saveSchedule()
     - Register with cronScheduler.scheduleWorkflow() if workflowId set
     - Send schedule.created response

   - `handleScheduleUpdate(ws, msg)`:
     - Update in DB via updateSchedule()
     - Stop old Croner job, re-schedule if still enabled
     - Send schedule.updated response

   - `handleScheduleDelete(ws, msg)`:
     - Delete from DB via deleteSchedule()
     - Stop Croner job
     - Send schedule.updated (or a simple ack)

   - `handleScheduleList(ws, msg)`:
     - Load all schedules from DB
     - Add nextRun from cronScheduler.nextRun() for each
     - Send schedule.list.result

   - `handleHeartbeatConfigure(ws, msg, connState)`:
     - Build a schedule config from heartbeat params: cronExpression from interval (e.g., `*/${interval} * * * *`), timezone, activeHours
     - Save as a schedule with a well-known ID prefix "heartbeat-"
     - Register with cronScheduler.scheduleHeartbeat()
     - onAlert callback sends heartbeat.alert server message via ws
     - Send heartbeat.configured response

2. Update `packages/gateway/src/ws/server.ts`:

   Import all 9 new handler functions.

   Add 9 new cases to the switch statement, following the existing pattern (logger.info, handler call with .catch() error boundary):

   ```
   case "workflow.trigger": { ... handleWorkflowTrigger(socket, msg, connState).catch(...) ... }
   case "workflow.approval": { ... handleWorkflowApproval(socket, msg, connState).catch(...) ... }
   case "workflow.list": { ... handleWorkflowList(socket, msg).catch(...) ... }
   case "workflow.execution.list": { ... handleWorkflowExecutionList(socket, msg).catch(...) ... }
   case "schedule.create": { ... handleScheduleCreate(socket, msg).catch(...) ... }
   case "schedule.update": { ... handleScheduleUpdate(socket, msg).catch(...) ... }
   case "schedule.delete": { ... handleScheduleDelete(socket, msg).catch(...) ... }
   case "schedule.list": { ... handleScheduleList(socket, msg).catch(...) ... }
   case "heartbeat.configure": { ... handleHeartbeatConfigure(socket, msg, connState).catch(...) ... }
   ```

   Also add to imports at top of server.ts from handlers.js.
  </action>
  <verify>
`pnpm --filter @agentspace/gateway exec tsc --noEmit` passes.
Grep for "workflow.trigger" in server.ts confirms wiring.
Grep for "handleScheduleCreate" in handlers.ts confirms handler exists.
Count of switch cases in server.ts shows 9 new cases added.
  </verify>
  <done>All workflow, schedule, and heartbeat WebSocket messages are wired end-to-end: protocol schemas validate input, handlers process business logic via engine/scheduler, server.ts dispatches to handlers. Clients can trigger workflows, approve gates, manage schedules, and configure heartbeat monitoring.</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @agentspace/gateway exec tsc --noEmit` â€” everything compiles
2. All 9 client message types in ClientMessageSchema union
3. All 9 server message types in ServerMessageSchema union
4. All 9 handler functions exported from handlers.ts
5. All 9 switch cases in server.ts
6. ConnectionState includes pendingWorkflowApprovals
</verification>

<success_criteria>
- Workflow trigger/approval/list/execution-list messages work end-to-end
- Schedule create/update/delete/list messages work end-to-end
- Heartbeat configure message creates a cron-scheduled heartbeat
- Heartbeat alerts sent to connected clients when action needed
- All messages validated by Zod schemas
- TypeScript compiles cleanly with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-workflows-scheduling/08-04-SUMMARY.md`
</output>
