---
phase: 10-claude-code-system-skills
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - packages/gateway/src/claude-code/approval-proxy.ts
  - packages/gateway/src/claude-code/session-manager.ts
  - packages/gateway/src/ws/protocol.ts
  - packages/gateway/src/ws/handlers.ts
  - packages/gateway/src/ws/connection.ts
  - packages/gateway/src/tools/claude-code.ts
  - packages/gateway/src/claude-code/index.ts
autonomous: true

user_setup:
  - service: anthropic
    why: "Claude Code Agent SDK requires an Anthropic API key or Claude.ai subscription"
    env_vars:
      - name: ANTHROPIC_API_KEY
        source: "Already configured in AgentSpace vault from Phase 1 setup"

must_haves:
  truths:
    - "Claude Code approval requests are proxied to the user's active transport and user can approve/deny"
    - "User can start a Claude Code session from any connected channel via WS protocol"
    - "Claude Code can be invoked as a tool within workflows"
    - "Approval requests fan out to ALL connected transports (not just the initiating one)"
  artifacts:
    - path: "packages/gateway/src/claude-code/approval-proxy.ts"
      provides: "canUseTool callback that proxies approvals to active transports"
      exports: ["createApprovalProxy"]
    - path: "packages/gateway/src/tools/claude-code.ts"
      provides: "Claude Code as an AI SDK tool for workflow integration"
      exports: ["createClaudeCodeTool"]
    - path: "packages/gateway/src/ws/handlers.ts"
      provides: "claude-code.start and claude-code.approval.response handler wiring"
      contains: "claude-code"
  key_links:
    - from: "packages/gateway/src/claude-code/approval-proxy.ts"
      to: "packages/gateway/src/transport.ts"
      via: "transport.send(tool.approval.request)"
      pattern: "transport\\.send.*tool\\.approval\\.request"
    - from: "packages/gateway/src/ws/handlers.ts"
      to: "packages/gateway/src/claude-code/session-manager.ts"
      via: "sessionManager.spawn() on claude-code.start message"
      pattern: "claude-code\\.start"
    - from: "packages/gateway/src/tools/claude-code.ts"
      to: "packages/gateway/src/claude-code/session-manager.ts"
      via: "sessionManager.runToCompletion() in tool execute"
      pattern: "runToCompletion"
---

<objective>
Wire Claude Code approval proxying, WS protocol messages, handler integration, and expose Claude Code as a workflow tool. This connects the session manager (10-01) to the full transport layer so users can start sessions, approve tool use, and orchestrate Claude Code in workflows.

Purpose: Completes CCDE-02, CCDE-03, CCDE-05 -- interactive prompt proxying across channels and workflow orchestration.

Output: Approval proxy module, WS protocol extensions, handler wiring, and claude-code workflow tool.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-claude-code-system-skills/10-RESEARCH.md
@.planning/phases/10-claude-code-system-skills/10-01-SUMMARY.md
@packages/gateway/src/ws/protocol.ts
@packages/gateway/src/ws/handlers.ts
@packages/gateway/src/ws/connection.ts
@packages/gateway/src/agent/tool-loop.ts
@packages/gateway/src/agent/approval-gate.ts
@packages/gateway/src/workflow/executor.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Approval proxy and WS protocol + handler wiring</name>
  <files>
    packages/gateway/src/claude-code/approval-proxy.ts
    packages/gateway/src/ws/protocol.ts
    packages/gateway/src/ws/handlers.ts
    packages/gateway/src/ws/connection.ts
    packages/gateway/src/claude-code/session-manager.ts
  </files>
  <action>
Create `packages/gateway/src/claude-code/approval-proxy.ts`:
- Export `createApprovalProxy(transport: Transport, requestId: string, connState: ConnectionState)` that returns a `canUseTool` callback function compatible with the Agent SDK
- The callback should:
  1. Auto-approve read-only tools (Read, Grep, Glob, WebFetch) by returning `{ behavior: "allow", updatedInput: input }`
  2. For other tools (Edit, Write, Bash, etc.), generate an `approvalId` via `crypto.randomUUID()`
  3. Send `transport.send({ type: "tool.approval.request", requestId, toolCallId: approvalId, toolName, args: input })` -- reuse existing `tool.approval.request` ServerMessage
  4. Wait for response using the existing `connState.pendingApprovals` Map pattern (store resolve callback keyed by approvalId)
  5. Implement `APPROVAL_TIMEOUT_MS` (60s) timeout that auto-denies, matching existing pattern from tool-loop.ts
  6. Return `{ behavior: "allow", updatedInput: input }` on approval or `{ behavior: "deny", message: "User denied permission" }` on denial
- The callback should also accept the `signal: AbortSignal` parameter from the SDK and abort-race against it

Add WS protocol messages to `packages/gateway/src/ws/protocol.ts`:
- Add `ClaudeCodeStartSchema` client message: `{ type: "claude-code.start", id: string, prompt: string, cwd: string, allowedTools?: string[], sessionId?: string }`
- Add `ClaudeCodeAbortSchema` client message: `{ type: "claude-code.abort", id: string, sessionId: string }`
- Add both to `ClientMessageSchema` discriminated union
- Export new types

Update `packages/gateway/src/ws/connection.ts`:
- Add `claudeCodeSessions: Map<string, string>` to `ConnectionState` (maps CC session ID -> requestId for tracking active CC sessions on a connection)
- Initialize as `new Map()` in `initConnection`

Wire handlers in `packages/gateway/src/ws/handlers.ts`:
- Add handler for `claude-code.start`: instantiate or get singleton `ClaudeCodeSessionManager`, call `spawn()` with the approval proxy callback, store session in connState.claudeCodeSessions. Send `chat.stream.start` to indicate session started.
- Add handler for `claude-code.abort`: look up session and call `abort()`
- The existing `tool.approval.response` handler already resolves `pendingApprovals` -- Claude Code approval responses will flow through the same path since we reuse the same Map
- Use dynamic import for claude-code module (`await import("../claude-code/index.js")`) matching existing pattern from workflow handlers (avoids circular deps)
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/gateway. Verify protocol.ts has new schemas in union. Verify handlers.ts has claude-code.start case.
  </verify>
  <done>Users can send "claude-code.start" over WS to spawn a Claude Code session. Tool approval requests are proxied via existing "tool.approval.request" protocol and resolved via existing "tool.approval.response" flow. Approvals reuse the pendingApprovals Map on ConnectionState.</done>
</task>

<task type="auto">
  <name>Task 2: Claude Code as a workflow tool</name>
  <files>
    packages/gateway/src/tools/claude-code.ts
    packages/gateway/src/claude-code/session-manager.ts
    packages/gateway/src/claude-code/index.ts
  </files>
  <action>
Create `packages/gateway/src/tools/claude-code.ts`:
- Import `tool` from "ai" and `z` from "zod"
- Export `createClaudeCodeTool(sessionManager: ClaudeCodeSessionManager)` that returns an AI SDK tool definition:
  - `description`: "Spawn a Claude Code session to perform a coding task. Claude Code can read, write, and edit files, run commands, and interact with the codebase."
  - `inputSchema`: `z.object({ prompt: z.string(), cwd: z.string().optional(), maxTurns: z.number().optional().default(10) })`
  - `execute`: async function that:
    1. Calls a new `sessionManager.runToCompletion(prompt, { cwd, maxTurns, permissionMode: "acceptEdits" })` method
    2. This method spawns a session with no approval proxy (workflows are pre-approved), collects all text output from the generator, and returns the final result text
    3. Returns `{ success: true, output: resultText, cost: totalCostUsd }` or `{ success: false, error: errorMessage }`

Add `runToCompletion` method to `ClaudeCodeSessionManager`:
- Accepts `prompt`, `options: { cwd?, maxTurns?, permissionMode? }`
- Spawns query with `permissionMode: "acceptEdits"` (auto-approve edits for workflow context)
- Does NOT relay to a transport -- just collects text output from the async generator
- Returns `{ text: string, costUsd: number }` on success
- Throws on error

Update `packages/gateway/src/claude-code/index.ts`:
- Add export for `createClaudeCodeTool` from `../tools/claude-code.js`
  </action>
  <verify>
Run `npx tsc --noEmit` from packages/gateway. Verify `createClaudeCodeTool` returns an AI SDK tool with correct inputSchema.
  </verify>
  <done>Claude Code can be invoked as an AI SDK tool within workflows via `createClaudeCodeTool`. The `runToCompletion` method runs headlessly with pre-approved permissions for workflow automation (CCDE-05).</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes in packages/gateway
2. WS protocol has `claude-code.start` and `claude-code.abort` client message types
3. Approval proxy reuses existing `tool.approval.request/response` flow
4. Claude Code workflow tool has correct AI SDK tool() signature
5. Handlers wire up claude-code.start to session manager spawn
</verification>

<success_criteria>
- Claude Code sessions can be started from any WS client via protocol message
- Approval requests proxy to the user's transport using existing approval infrastructure
- Claude Code tool can be used in workflow steps with pre-approved permissions
- No new ServerMessage types needed -- existing protocol handles all Claude Code events
</success_criteria>

<output>
After completion, create `.planning/phases/10-claude-code-system-skills/10-02-SUMMARY.md`
</output>
