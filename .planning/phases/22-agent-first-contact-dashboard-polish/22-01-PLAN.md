---
phase: 22-agent-first-contact-dashboard-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/db/memory-files/FIRST_CONTACT.md
  - packages/gateway/src/context/assembler.ts
  - packages/gateway/src/tools/memory.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "First tek chat session with a new agent triggers first-contact greeting behavior"
    - "Agent introduces itself by name and greets the user by name"
    - "Agent asks conversational questions about the user"
    - "memory_write tool writes to agent-specific USER.md, not global"
    - "First-contact prompt disappears once USER.md has meaningful content"
  artifacts:
    - path: "packages/db/memory-files/FIRST_CONTACT.md"
      provides: "First-contact system prompt template"
      min_lines: 15
    - path: "packages/gateway/src/context/assembler.ts"
      provides: "Conditional first-contact prompt injection"
      contains: "buildFirstContactPrompt"
    - path: "packages/gateway/src/tools/memory.ts"
      provides: "Agent-aware memory_write for identity files"
      contains: "createMemoryWriteTool(agentId"
  key_links:
    - from: "packages/gateway/src/context/assembler.ts"
      to: "packages/db/memory-files/FIRST_CONTACT.md"
      via: "first-contact detection based on USER.md content length"
      pattern: "isFirstContact"
    - from: "packages/gateway/src/tools/memory.ts"
      to: "packages/db/src/memory/agent-resolver.ts"
      via: "agent-scoped identity file writes"
      pattern: "agentId.*identity"
---

<objective>
Implement first-contact system prompt injection and agent-aware memory writes so that a new agent's first chat session feels alive -- greeting the user by name, introducing itself with personality, and writing learned information to the correct agent-specific USER.md.

Purpose: This is the core "first chat experience" that makes agents feel like individuals rather than generic chatbots. Without it, a freshly onboarded agent has no idea how to greet or interact with the user.

Output: First-contact prompt template, conditional injection in assembleContext(), agent-aware memory_write tool.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-agent-first-contact-dashboard-polish/22-RESEARCH.md
@packages/gateway/src/context/assembler.ts
@packages/gateway/src/tools/memory.ts
@packages/db/memory-files/USER.md
@packages/db/memory-files/BOOTSTRAP.md
@packages/db/src/memory/agent-resolver.ts
@packages/db/src/memory/identity-manager.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create first-contact template and inject into assembleContext</name>
  <files>
    packages/db/memory-files/FIRST_CONTACT.md
    packages/gateway/src/context/assembler.ts
  </files>
  <action>
1. Create `packages/db/memory-files/FIRST_CONTACT.md` with a concise first-contact protocol (under 200 tokens to stay within budget). Content should instruct the agent to:
   - Greet the user by name (from `userDisplayName` in config) or ask their name
   - Introduce itself using its name and personality from the identity sections above
   - Ask 2-3 natural conversational questions about: what the user primarily needs help with, their communication preferences, and any tools/workflows they use
   - Use the memory_write tool (target: "identity", file: "USER.md") to save what it learns
   - Be conversational, not clinical -- feel like meeting a smart colleague
   - This instruction self-disables once USER.md has meaningful content

2. In `packages/gateway/src/context/assembler.ts`:
   - Add `import { loadConfig } from "@tek/core"` (already imported, just use it)
   - Add a `buildFirstContactPrompt(agentId?: string): string` function that:
     - Loads config to get agent name from `config.agents.list.find(a => a.id === agentId)?.name`
     - Gets user display name from `config.userDisplayName`
     - Returns the first-contact prompt text with agent name and user name interpolated
     - Returns empty string if config or agent not found
   - In `assembleContext()`, after loading `memoryCtx`, detect first contact:
     ```typescript
     const isFirstContact = !memoryCtx.user || memoryCtx.user.trim().length < 50;
     const firstContactPrompt = isFirstContact ? buildFirstContactPrompt(agentId) : "";
     ```
   - Add the first-contact block to `systemParts` array AFTER the user section:
     ```typescript
     firstContactPrompt ? `\n\n# First Contact Instructions\n${firstContactPrompt}` : "",
     ```
   - Add a measured section: `addSection(sections, "first_contact", firstContactPrompt, pricing.inputPerMTok);`

Note: The existing BOOTSTRAP.md template is from Phase 18 and expects a different flow (delete the file after setup). The new FIRST_CONTACT.md uses the system prompt approach which is self-disabling based on USER.md content length. Do NOT modify or delete BOOTSTRAP.md.
  </action>
  <verify>
TypeScript compiles: `cd /Users/hitekmedia/Documents/GitHub/tek && npx tsc --noEmit -p packages/gateway/tsconfig.json 2>&1 | head -20`

Verify FIRST_CONTACT.md exists and is under 200 tokens (roughly 800 chars): `wc -c packages/db/memory-files/FIRST_CONTACT.md`

Verify assembler has buildFirstContactPrompt: `grep -n "buildFirstContactPrompt" packages/gateway/src/context/assembler.ts`

Verify isFirstContact detection: `grep -n "isFirstContact" packages/gateway/src/context/assembler.ts`
  </verify>
  <done>
assembleContext() conditionally injects first-contact instructions when USER.md is empty/sparse (< 50 chars). The prompt includes agent name and user name from config. FIRST_CONTACT.md template exists under 200 tokens.
  </done>
</task>

<task type="auto">
  <name>Task 2: Make memory_write tool agent-aware for identity file writes</name>
  <files>
    packages/gateway/src/tools/memory.ts
  </files>
  <action>
1. In `packages/gateway/src/tools/memory.ts`:
   - Change `createMemoryWriteTool()` signature to accept `agentId?: string` parameter:
     ```typescript
     export function createMemoryWriteTool(agentId?: string) {
     ```
   - Import `resolveAgentDir` from `@tek/db` (it's already available as an export)
   - In the `identity` case of the switch, use agent-scoped file writing:
     - Import `writeFileSync` from `node:fs` and `join` from `node:path`
     - When agentId is provided (truthy and not "default"), resolve the agent directory via `resolveAgentDir(agentId)` and write the identity file there instead of using the global `updateIdentityFileSection()` which writes to the global memory path
     - For the agent-scoped path: construct `join(resolveAgentDir(agentId), identityFile)` and use `writeFileSync` for full-file writes, OR better: call `updateIdentityFileSection(identityFile, identitySection, content, agentId)` if the function supports an agentId parameter
   - Check if `updateIdentityFileSection` in `@tek/db` accepts agentId. If not, add the agentId parameter to it:
     - In `packages/db/src/memory/identity-manager.ts`, find `updateIdentityFileSection` and add an optional `agentId?: string` parameter
     - Use `resolveAgentDir(agentId)` instead of `GLOBAL_MEMORY_DIR` to resolve the file path when agentId is provided
   - Also update the `loadUser()` call in `createMemoryReadTool` to pass agentId (currently line 62: `content = loadUser()` should be `content = loadUser(agentId)`)
   - Check if `loadUser` accepts agentId. If not:
     - In `packages/db/src/memory/identity-manager.ts`, add `loadUser(agentId?: string)` that uses `resolveIdentityFile(agentId, "USER.md")` for agent-scoped resolution

2. In `packages/gateway/src/agent/tool-registry.ts`, find where `createMemoryWriteTool()` is called and pass the `agentId`:
   - It should already receive agentId in the options. Change `createMemoryWriteTool()` to `createMemoryWriteTool(opts.agentId)`.

Note: The memory_read tool already receives agentId for SOUL/IDENTITY/STYLE but NOT for USER.md (line 62 calls `loadUser()` without agentId). Fix this too.
  </action>
  <verify>
TypeScript compiles: `cd /Users/hitekmedia/Documents/GitHub/tek && npx tsc --noEmit -p packages/gateway/tsconfig.json 2>&1 | head -20`

Verify createMemoryWriteTool accepts agentId: `grep -n "createMemoryWriteTool" packages/gateway/src/tools/memory.ts`

Verify memory_read passes agentId to loadUser: `grep -n "loadUser" packages/gateway/src/tools/memory.ts`

Verify tool-registry passes agentId to write tool: `grep -n "createMemoryWriteTool" packages/gateway/src/agent/tool-registry.ts`
  </verify>
  <done>
memory_write tool accepts agentId and writes identity files to agent-specific directories. memory_read passes agentId to loadUser for USER.md reads. Tool registry passes agentId to both memory tool factories. Agent A's first-contact notes write to its own USER.md, not global.
  </done>
</task>

</tasks>

<verification>
1. `FIRST_CONTACT.md` exists at `packages/db/memory-files/FIRST_CONTACT.md`
2. `assembleContext()` injects first-contact prompt when USER.md is sparse
3. `createMemoryWriteTool(agentId)` writes to agent-specific directories
4. `createMemoryReadTool(agentId)` reads USER.md from agent-specific directory
5. All packages compile without TypeScript errors
</verification>

<success_criteria>
- First chat with a new agent (empty USER.md) triggers first-contact system prompt
- Agent knows its own name and the user's name from config
- Agent writes learned info to its own USER.md via memory_write tool
- Subsequent chats (USER.md > 50 chars) do NOT trigger first-contact prompt
- No regression in existing identity file loading for established agents
</success_criteria>

<output>
After completion, create `.planning/phases/22-agent-first-contact-dashboard-polish/22-01-SUMMARY.md`
</output>
