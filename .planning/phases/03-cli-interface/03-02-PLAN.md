---
phase: 03-cli-interface
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - packages/cli/src/components/MessageList.tsx
  - packages/cli/src/components/MessageBubble.tsx
  - packages/cli/src/components/StreamingResponse.tsx
  - packages/cli/src/components/InputBar.tsx
  - packages/cli/src/components/StatusBar.tsx
  - packages/cli/src/components/MarkdownRenderer.tsx
  - packages/cli/src/lib/markdown.ts
  - packages/cli/src/hooks/useSlashCommands.ts
  - packages/cli/src/components/Chat.tsx
  - packages/cli/src/index.ts
autonomous: true

must_haves:
  truths:
    - "User sees each message styled differently by role: user messages have a 'You' prefix, assistant messages render as markdown with syntax-highlighted code blocks, system/error messages appear in distinct color"
    - "Streaming assistant response displays as plain text while arriving, then re-renders as full markdown when stream completes"
    - "User can type /help and see a list of available slash commands"
    - "User can type /model <name> to switch models, /session new to start a new session, /session list to list sessions, /usage to see token counts, /clear to clear screen, /quit to exit"
    - "Status bar shows connection state, current session ID, active model, and running token/cost totals"
    - "agentspace (no args) launches chat if onboarding is complete and gateway is running"
  artifacts:
    - path: "packages/cli/src/components/MessageBubble.tsx"
      provides: "Single message display with role-based styling"
      exports: ["MessageBubble"]
    - path: "packages/cli/src/components/MessageList.tsx"
      provides: "Static list of completed messages"
      exports: ["MessageList"]
    - path: "packages/cli/src/components/StreamingResponse.tsx"
      provides: "Live-updating streaming text display"
      exports: ["StreamingResponse"]
    - path: "packages/cli/src/components/InputBar.tsx"
      provides: "Text input with slash command interception"
      exports: ["InputBar"]
    - path: "packages/cli/src/components/StatusBar.tsx"
      provides: "Connection, session, model, usage status display"
      exports: ["StatusBar"]
    - path: "packages/cli/src/components/MarkdownRenderer.tsx"
      provides: "Ink component wrapping marked-terminal output"
      exports: ["MarkdownRenderer"]
    - path: "packages/cli/src/lib/markdown.ts"
      provides: "marked + marked-terminal configuration"
      exports: ["renderMarkdown"]
    - path: "packages/cli/src/hooks/useSlashCommands.ts"
      provides: "Slash command parsing and dispatch"
      exports: ["useSlashCommands"]
  key_links:
    - from: "packages/cli/src/components/MessageBubble.tsx"
      to: "packages/cli/src/components/MarkdownRenderer.tsx"
      via: "Renders assistant content through MarkdownRenderer"
      pattern: "MarkdownRenderer"
    - from: "packages/cli/src/components/InputBar.tsx"
      to: "packages/cli/src/hooks/useSlashCommands.ts"
      via: "Intercepts /commands before sending as chat"
      pattern: "processInput|startsWith.*/"
    - from: "packages/cli/src/lib/markdown.ts"
      to: "marked-terminal"
      via: "marked.setOptions with TerminalRenderer"
      pattern: "TerminalRenderer"
    - from: "packages/cli/src/hooks/useSlashCommands.ts"
      to: "packages/cli/src/lib/gateway-client.ts"
      via: "Uses message factories for session.list, usage.query, etc."
      pattern: "createSessionListMessage|createUsageQueryMessage"
---

<objective>
Build the polished UI components (MessageBubble, MessageList, StreamingResponse, InputBar, StatusBar, MarkdownRenderer), slash command system, and markdown rendering. Wire everything into the Chat component to deliver the full Claude Code-style terminal experience.

Purpose: Transform the minimal chat shell from Plan 03-01 into a polished, usable CLI that satisfies all four Phase 3 success criteria.
Output: Complete terminal chat interface with markdown rendering, syntax highlighting, slash commands, and status display.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-cli-interface/03-RESEARCH.md
@.planning/phases/03-cli-interface/03-01-SUMMARY.md
@packages/cli/src/components/Chat.tsx
@packages/cli/src/hooks/useChat.ts
@packages/cli/src/hooks/useWebSocket.ts
@packages/cli/src/lib/gateway-client.ts
@packages/gateway/src/ws/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create markdown renderer, UI components, and StatusBar</name>
  <files>
    packages/cli/src/lib/markdown.ts
    packages/cli/src/components/MarkdownRenderer.tsx
    packages/cli/src/components/MessageBubble.tsx
    packages/cli/src/components/MessageList.tsx
    packages/cli/src/components/StreamingResponse.tsx
    packages/cli/src/components/StatusBar.tsx
  </files>
  <action>
1. Create `packages/cli/src/lib/markdown.ts`:
   - Import `marked` from `marked`
   - Import `default as TerminalRenderer` from `marked-terminal` (check actual export — may need `import TerminalRenderer from "marked-terminal"` or `const { default: TerminalRenderer } = await import("marked-terminal")` depending on ESM compat)
   - Configure marked once at module level:
     ```
     marked.setOptions({
       renderer: new TerminalRenderer({
         width: process.stdout.columns || 80,
         tab: 2,
         reflowText: true,
       }),
     });
     ```
   - Export `renderMarkdown(text: string): string` — calls `marked.parse(text)` and returns the result as string
   - Handle edge case: if text is empty or only whitespace, return it as-is

2. Create `packages/cli/src/components/MarkdownRenderer.tsx`:
   - Import React, `Text` from `ink`
   - Import `renderMarkdown` from `../lib/markdown.js`
   - Props: `{ content: string }`
   - Render: `<Text>{renderMarkdown(content)}</Text>`
   - Export as named export `MarkdownRenderer`

3. Create `packages/cli/src/components/MessageBubble.tsx`:
   - Import React, `Box`, `Text` from `ink`
   - Import `ChatMessage` from `../lib/gateway-client.js`
   - Import `MarkdownRenderer` from `./MarkdownRenderer.js`
   - Props: `{ message: ChatMessage }`
   - Render based on role:
     - `user`: `<Box><Text bold color="cyan">{"❯ "}</Text><Text>{message.content}</Text></Box>` — user messages displayed as plain text with a prompt indicator
     - `assistant`: `<Box flexDirection="column"><Text bold color="magenta">{"◆ Assistant"}</Text><MarkdownRenderer content={message.content} /></Box>` — full markdown rendering for completed assistant messages
     - `system`: `<Box><Text color="yellow" dimColor>{"⚠ "}{message.content}</Text></Box>` — dimmed yellow for system/error messages
   - Add a blank line (marginBottom={1}) between messages for readability

4. Create `packages/cli/src/components/MessageList.tsx`:
   - Import React, `Static` from `ink`
   - Import `ChatMessage` from `../lib/gateway-client.js`
   - Import `MessageBubble` from `./MessageBubble.js`
   - Props: `{ messages: ChatMessage[] }`
   - Render: `<Static items={messages}>{(msg) => <MessageBubble key={msg.id} message={msg} />}</Static>`
   - This uses Ink's Static to render completed messages exactly once (no re-renders)

5. Create `packages/cli/src/components/StreamingResponse.tsx`:
   - Import React, `Box`, `Text` from `ink`
   - Import `Spinner` from `@inkjs/ui`
   - Props: `{ text: string; model?: string }`
   - Render:
     - `<Box flexDirection="column">`
     - `<Box><Text bold color="magenta">{"◆ Assistant"}</Text>{model && <Text dimColor> ({model})</Text>}</Box>`
     - If text is empty: show `<Spinner label="Thinking..." />`
     - If text has content: `<Text>{text}</Text>` — plain text only during streaming (no markdown to avoid partial-parse artifacts per research pitfall #1)
     - `</Box>`

6. Create `packages/cli/src/components/StatusBar.tsx`:
   - Import React, `Box`, `Text` from `ink`
   - Props: `{ connected: boolean; sessionId: string | null; model: string; usage: { totalTokens: number; totalCost: number } }`
   - Render a single-line status bar at the top:
     - `<Box borderStyle="single" borderColor="gray" paddingX={1} justifyContent="space-between">`
     - Left: connection indicator dot (green "●" if connected, red "●" if not) + "AgentSpace"
     - Center: session ID (truncated to 8 chars) or "No session"
     - Right: model name (shortened, e.g., "sonnet-4.5") + token count + cost formatted as "$X.XXXX"
     - `</Box>`
   - Format cost: `$${usage.totalCost.toFixed(4)}`
   - Format tokens: `${usage.totalTokens.toLocaleString()} tok`
  </action>
  <verify>
    Run `pnpm --filter @agentspace/cli build` — compiles without errors. Verify all 6 files exist and export their named components/functions.
  </verify>
  <done>
    markdown.ts configures marked with terminal renderer and syntax highlighting. MarkdownRenderer wraps it in an Ink Text component. MessageBubble renders messages with role-based styling (user = cyan prompt, assistant = markdown, system = yellow). MessageList uses Static for efficient append-only rendering. StreamingResponse shows plain text during streaming with a spinner for empty state. StatusBar shows connection, session, model, tokens, and cost. All compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create slash command system, InputBar, wire Chat component, and update default command</name>
  <files>
    packages/cli/src/hooks/useSlashCommands.ts
    packages/cli/src/components/InputBar.tsx
    packages/cli/src/components/Chat.tsx
    packages/cli/src/index.ts
  </files>
  <action>
1. Create `packages/cli/src/hooks/useSlashCommands.ts`:
   - Import `useCallback` from `react`
   - Import `ClientMessage` from `@agentspace/gateway`
   - Import `ChatMessage` from `../lib/gateway-client.js`
   - Import `createUsageQueryMessage`, `createSessionListMessage` from `../lib/gateway-client.js`
   - Define `SlashCommandResult` type: `{ handled: boolean; message?: ChatMessage; wsMessage?: ClientMessage; action?: "clear" | "quit" | "help" | "model-switch" }`
   - Export `useSlashCommands()` returning `{ processInput: (input: string, context: { sessionId: string | null; model: string }) => SlashCommandResult }`
   - Slash command handlers:
     - `/help`: Return `{ handled: true, action: "help", message: system ChatMessage listing all commands }`
       Help text: "/model <name> — Switch model\n/session new — New session\n/session list — List sessions\n/context — Inspect context\n/usage — Show usage stats\n/clear — Clear screen\n/quit — Exit\n/help — Show this help"
     - `/model <name>`: Return `{ handled: true, action: "model-switch", message: system ChatMessage "Switched to model: {name}" }` — the actual model value is extracted from args and the Chat component updates its model state
     - `/session new`: Return `{ handled: true, message: system ChatMessage "Starting new session..." }` — Chat component should set sessionId to null so next chat.send creates a new session
     - `/session list`: Return `{ handled: true, wsMessage: createSessionListMessage() }`
     - `/usage`: Return `{ handled: true, wsMessage: createUsageQueryMessage(context.sessionId) }`
     - `/context`: Return `{ handled: true, wsMessage: createContextInspectMessage(context.sessionId) }` if sessionId exists, else error message
     - `/clear`: Return `{ handled: true, action: "clear" }`
     - `/quit` or `/exit`: Return `{ handled: true, action: "quit" }`
     - Unknown `/xxx`: Return `{ handled: true, message: system ChatMessage "Unknown command: /xxx. Type /help for available commands." }`
   - Non-slash input: Return `{ handled: false }`
   - Import `createContextInspectMessage` from gateway-client as well

2. Create `packages/cli/src/components/InputBar.tsx`:
   - Import React, `useState` from `react`
   - Import `Box`, `Text` from `ink`
   - Import `TextInput` from `@inkjs/ui`
   - Props: `{ onSubmit: (text: string) => void; isStreaming: boolean }`
   - State: internal value string for TextInput
   - Render:
     - `<Box>`
     - `<Text bold color="cyan">{"❯ "}</Text>`
     - `<TextInput placeholder="Send a message..." value={value} onChange={setValue} onSubmit={handleSubmit} isDisabled={isStreaming} />` — Note: check @inkjs/ui TextInput API; it may use `onSubmit` or `onConfirm`. Use the correct prop name.
     - If isStreaming: show `<Text dimColor> (streaming...)</Text>` indicator
     - `</Box>`
   - On submit: if value is non-empty after trim, call `onSubmit(value.trim())` and reset value to ""

3. Rewrite `packages/cli/src/components/Chat.tsx`:
   - Import all new components: MessageList, StreamingResponse, InputBar, StatusBar
   - Import useSlashCommands hook
   - Import useApp from ink (for exit())
   - Import createChatSendMessage from gateway-client
   - Full component structure:
     ```
     <Box flexDirection="column">
       <StatusBar connected={...} sessionId={...} model={...} usage={...} />
       <MessageList messages={messages} />
       {streamingText !== undefined && streamingText !== "" ? (
         <StreamingResponse text={streamingText} model={model} />
       ) : null}
       {/* Also show StreamingResponse with empty text when we get stream.start but no delta yet */}
       <InputBar onSubmit={handleSubmit} isStreaming={isStreaming} />
     </Box>
     ```
   - `handleSubmit` logic:
     1. Call `processInput(input, { sessionId, model })`
     2. If `result.handled`:
        - If `result.message`: push to messages via a new `addSystemMessage` function in useChat (or just use addUserMessage pattern — add a generic `addMessage` to useChat)
        - If `result.wsMessage`: call `send(result.wsMessage)`
        - If `result.action === "quit"`: call `exit()`
        - If `result.action === "clear"`: clear messages array (add `clearMessages` to useChat)
        - If `result.action === "model-switch"`: extract model name from input, update model in useChat state (add `setModel` to useChat)
        - If `result.action === "help"`: add the help message to messages
     3. If not handled: regular chat message — call `addUserMessage(input)`, then `send(createChatSendMessage(input, { sessionId, model }))`
   - Add `isStreaming` derived state: true when streamingText is non-empty or when between stream.start and stream.end. Add this to useChat if needed (a simple boolean state toggled by stream.start → true, stream.end → false)
   - Handle `session.list` and `usage.report` and `context.inspection` responses in useChat: format them as system ChatMessages so they appear in the message list. For session.list: format as a table-like string. For usage.report: format as a summary string. For context.inspection: format section names with byte/token counts.

4. Update `packages/cli/src/index.ts`:
   - Import `discoverGateway` from `./lib/discovery.js`
   - Import `configExists` from `@agentspace/core`
   - Update the default action (when no subcommand):
     - If not configured: suggest `agentspace init` (existing behavior)
     - If configured: check `discoverGateway()`. If gateway running, auto-launch chat (import chatCommand and invoke its action). If not running, print "Run the gateway first, then use `agentspace chat`" and show help.
   - This makes `agentspace` (no args) launch chat when everything is ready, matching Claude Code UX.
  </action>
  <verify>
    Run `pnpm --filter @agentspace/cli build` — compiles without errors. Run `agentspace chat --help` to confirm command is available. With a running gateway, run `agentspace chat` and verify: StatusBar appears at top, typing text and pressing Enter sends it (message appears), typing `/help` shows command list, typing `/quit` exits.
  </verify>
  <done>
    Slash commands dispatch correctly: /help shows command list, /model switches model, /session new/list work, /usage queries gateway, /context inspects context, /clear clears messages, /quit exits. InputBar shows prompt with streaming indicator. Chat component wires all components together with proper state flow. StatusBar displays live connection/session/model/usage info. `agentspace` (no args) launches chat when configured and gateway is running. Full Phase 3 CLI experience is functional. Build passes.
  </done>
</task>

</tasks>

<verification>
1. `pnpm --filter @agentspace/cli build` passes with zero errors
2. Start gateway (`node packages/gateway/dist/index.js`), then run `agentspace chat`
3. Verify StatusBar shows "Connected" with green indicator, model name, session info
4. Type a message — user message appears with cyan prompt, assistant response streams in plain text then renders as markdown when complete
5. Type `/help` — shows all available slash commands
6. Type `/model claude-opus-4-20250514` — shows model switch confirmation in status bar
7. Type `/usage` — shows token usage report
8. Type `/quit` — exits cleanly
9. Run `agentspace` (no args) — launches chat if configured and gateway running
10. Send a message that includes a code block in the response — verify syntax highlighting renders correctly in the completed message
</verification>

<success_criteria>
- Messages styled by role: user (cyan prompt), assistant (markdown rendered), system (yellow)
- Streaming shows plain text; completed messages show full markdown with syntax-highlighted code
- All 8 slash commands work: /help, /model, /session (new/list), /context, /usage, /clear, /quit
- StatusBar shows connection, session, model, token count, cost
- `agentspace` (no args) auto-launches chat when ready
- Build passes with zero TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-cli-interface/03-02-SUMMARY.md`
</output>
