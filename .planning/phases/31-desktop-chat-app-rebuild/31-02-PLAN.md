---
phase: 31-desktop-chat-app-rebuild
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - apps/desktop/src/lib/discovery.ts
  - apps/desktop/src/lib/config.ts
  - apps/desktop/src/hooks/useGateway.ts
  - apps/desktop/src/hooks/useConfig.ts
  - apps/desktop/src/components/GatewayStatus.tsx
  - apps/desktop/src/components/Layout.tsx
  - apps/desktop/src/views/LandingView.tsx
  - apps/desktop/src/App.tsx
autonomous: true
requirements:
  - DESK-01
  - DESK-02

must_haves:
  truths:
    - "App discovers gateway by reading ~/.config/tek/runtime.json via Tauri FS plugin"
    - "Health check validates gateway is actually running (not stale runtime.json)"
    - "Landing view shows gateway status with visual indicator (running=green, stopped=red, unknown=gray)"
    - "Landing view auto-transitions to chat view when gateway is detected running"
    - "Landing view shows CLI hint 'tek gateway start' when gateway is stopped"
  artifacts:
    - path: "apps/desktop/src/lib/discovery.ts"
      provides: "Gateway discovery via runtime.json + health check"
      exports: ["discoverGateway"]
      min_lines: 20
    - path: "apps/desktop/src/hooks/useGateway.ts"
      provides: "Gateway discovery polling hook"
      exports: ["useGateway"]
      min_lines: 15
    - path: "apps/desktop/src/views/LandingView.tsx"
      provides: "Landing page with gateway status and chat transition"
      min_lines: 30
    - path: "apps/desktop/src/components/Layout.tsx"
      provides: "App shell with header bar"
      min_lines: 15
  key_links:
    - from: "apps/desktop/src/hooks/useGateway.ts"
      to: "apps/desktop/src/lib/discovery.ts"
      via: "polling interval calling discoverGateway()"
      pattern: "discoverGateway"
    - from: "apps/desktop/src/hooks/useGateway.ts"
      to: "apps/desktop/src/stores/app-store.ts"
      via: "setGateway() updating store"
      pattern: "setGateway"
    - from: "apps/desktop/src/views/LandingView.tsx"
      to: "apps/desktop/src/stores/app-store.ts"
      via: "reading gateway state and triggering view change"
      pattern: "useAppStore"
---

<objective>
Implement gateway discovery (reading runtime.json via Tauri FS plugin with health check validation) and the Landing view that displays gateway connection status. The landing page auto-transitions to chat when gateway is running.

Purpose: The landing page is the first thing users see -- it establishes whether they can chat. Gateway discovery is the foundation for all WebSocket communication in later plans.
Output: Working landing page with real-time gateway status polling and automatic chat transition.
</objective>

<execution_context>
@/Users/drew-mini/.claude/get-shit-done/workflows/execute-plan.md
@/Users/drew-mini/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-desktop-chat-app-rebuild/31-RESEARCH.md
@.planning/phases/31-desktop-chat-app-rebuild/31-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gateway discovery and config loading utilities</name>
  <files>
    apps/desktop/src/lib/discovery.ts
    apps/desktop/src/lib/config.ts
    apps/desktop/src/hooks/useGateway.ts
    apps/desktop/src/hooks/useConfig.ts
  </files>
  <action>
    1. **src/lib/discovery.ts**: Create discoverGateway() async function:
       - Import homeDir, join from @tauri-apps/api/path
       - Import exists, readTextFile from @tauri-apps/plugin-fs
       - Read ~/.config/tek/runtime.json via Tauri FS plugin
       - If file doesn't exist, return null
       - Parse JSON to get { pid, port, startedAt }
       - Validate with HTTP health check: fetch(`http://127.0.0.1:${port}/health`, { signal: AbortSignal.timeout(2000) })
       - If health check succeeds (res.ok), return { pid, port, startedAt }
       - If health check fails, return null (stale runtime.json)
       - Export RuntimeInfo type: { pid: number; port: number; startedAt: string }

    2. **src/lib/config.ts**: Create loadConfig() async function:
       - Read ~/.config/tek/config.json via Tauri FS plugin
       - Parse and return typed config object (simplified AppConfig type with agents, defaultModel, agentName fields)
       - Return null if file doesn't exist
       - Export TekConfig type with: agents?: { list: { id: string; name?: string; model?: string; description?: string }[]; defaultAgentId?: string }, defaultModel?: string, agentName?: string

    3. **src/hooks/useGateway.ts**: Create useGateway() hook:
       - On mount, call discoverGateway() immediately
       - Set up 5-second polling interval
       - Update app store gateway state via setGateway()
       - Clean up interval on unmount
       - Return { status, port, isPolling }

    4. **src/hooks/useConfig.ts**: Create useConfig() hook:
       - On mount, call loadConfig()
       - Store in local state (not Zustand -- config is read-once)
       - Return { config, loading, error }
  </action>
  <verify>
    - `grep "discoverGateway" apps/desktop/src/lib/discovery.ts` matches
    - `grep "loadConfig" apps/desktop/src/lib/config.ts` matches
    - `grep "useGateway" apps/desktop/src/hooks/useGateway.ts` matches
    - `grep "useConfig" apps/desktop/src/hooks/useConfig.ts` matches
    - All files compile without TypeScript errors
  </verify>
  <done>
    Gateway discovery reads runtime.json, validates with health check, and polls every 5s. Config loader reads agents and settings from config.json. Both are available as React hooks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Landing view with gateway status and Layout shell</name>
  <files>
    apps/desktop/src/components/GatewayStatus.tsx
    apps/desktop/src/components/Layout.tsx
    apps/desktop/src/views/LandingView.tsx
    apps/desktop/src/App.tsx
  </files>
  <action>
    1. **src/components/GatewayStatus.tsx**: Create status indicator component:
       - Accept props: status ('unknown' | 'running' | 'stopped'), port (number | null)
       - Show colored dot: green for running, red for stopped, gray/pulsing for unknown
       - Show text: "Connected on port {port}" for running, "Gateway not detected" for stopped, "Checking..." for unknown
       - Use shadcn Badge component for the status pill
       - Use lucide-react icons: Wifi for connected, WifiOff for stopped, Loader2 (spinning) for unknown

    2. **src/components/Layout.tsx**: Create app shell layout:
       - Full-height flex column
       - Header bar: fixed top, shows "Tek" branding (text, no image), gateway status indicator (small) at top-right
       - Content area: flex-1 overflow-auto for page content
       - Accept children prop for content
       - Use Separator between header and content

    3. **src/views/LandingView.tsx**: Create landing page:
       - Center content vertically and horizontally
       - Large GatewayStatus component
       - When running: show "Start Chat" button (shadcn Button) that calls setCurrentView('chat')
       - When stopped: show helpful message with code block: `tek gateway start`
       - When unknown: show subtle loading spinner
       - Use useGateway() hook to trigger discovery
       - Auto-transition: useEffect that calls setCurrentView('chat') when gateway.status changes to 'running' (with 500ms delay for visual feedback)

    4. **Update src/App.tsx**: Replace placeholder views with real components:
       - Import Layout, LandingView
       - Create a ChatView placeholder (simple div with "Chat coming soon" text)
       - Wrap everything in Layout
       - Switch on currentView: 'landing' -> LandingView, 'chat' -> placeholder ChatView
       - Keep ErrorBoundary wrapping
  </action>
  <verify>
    - `grep "GatewayStatus" apps/desktop/src/components/GatewayStatus.tsx` matches
    - `grep "LandingView" apps/desktop/src/views/LandingView.tsx` matches
    - `grep "Layout" apps/desktop/src/components/Layout.tsx` matches
    - `grep "LandingView" apps/desktop/src/App.tsx` matches
    - All component files have proper React imports and export default/named exports
  </verify>
  <done>
    Landing view displays gateway connection status with colored indicators. When gateway is running, shows "Start Chat" button and auto-transitions to chat view after brief delay. When stopped, shows CLI hint. Layout shell provides consistent header with branding and status.
  </done>
</task>

</tasks>

<verification>
- Gateway discovery correctly reads runtime.json via Tauri FS (not Node.js fs)
- Health check uses fetch with AbortSignal.timeout(2000) to detect stale files
- Landing view shows 3 distinct states: running (green + button), stopped (red + CLI hint), unknown (gray + spinner)
- Auto-transition fires when gateway becomes available
- Layout provides consistent header across all views
- No Node.js imports in any frontend file (only Tauri plugin imports for FS access)
</verification>

<success_criteria>
When the desktop app launches, users see a landing page showing whether the gateway is running. If running, they can click to start chatting or it auto-transitions. If stopped, they see clear instructions to start it.
</success_criteria>

<output>
After completion, create `.planning/phases/31-desktop-chat-app-rebuild/31-02-SUMMARY.md`
</output>
