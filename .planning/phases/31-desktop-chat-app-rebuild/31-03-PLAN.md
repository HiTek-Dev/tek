---
phase: 31-desktop-chat-app-rebuild
plan: 03
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - apps/desktop/src/lib/gateway-client.ts
  - apps/desktop/src/hooks/useWebSocket.ts
  - apps/desktop/src/hooks/useChat.ts
autonomous: true
requirements:
  - DESK-03
  - DESK-05

must_haves:
  truths:
    - "Desktop connects to gateway WebSocket using Tauri plugin (not browser WebSocket)"
    - "WebSocket auto-reconnects with exponential backoff (1s, 2s, 4s, 8s, max 30s)"
    - "Chat state tracks messages array, streaming text buffer, active session, and model"
    - "Sending a message creates a chat.send client message and appends user message to state"
    - "Streaming deltas accumulate into a text buffer that becomes a completed message on stream end"
  artifacts:
    - path: "apps/desktop/src/lib/gateway-client.ts"
      provides: "WS protocol message factories and types"
      exports: ["createChatSend", "createSessionList", "createToolApprovalResponse"]
      min_lines: 40
    - path: "apps/desktop/src/hooks/useWebSocket.ts"
      provides: "Tauri WebSocket connection with auto-reconnect"
      exports: ["useWebSocket"]
      min_lines: 50
    - path: "apps/desktop/src/hooks/useChat.ts"
      provides: "Chat state management (messages, streaming, sessions)"
      exports: ["useChat"]
      min_lines: 60
  key_links:
    - from: "apps/desktop/src/hooks/useChat.ts"
      to: "apps/desktop/src/hooks/useWebSocket.ts"
      via: "send() function and onMessage handler"
      pattern: "useWebSocket"
    - from: "apps/desktop/src/hooks/useChat.ts"
      to: "apps/desktop/src/lib/gateway-client.ts"
      via: "message factory functions"
      pattern: "createChatSend"
    - from: "apps/desktop/src/hooks/useWebSocket.ts"
      to: "@tauri-apps/plugin-websocket"
      via: "WebSocket Tauri plugin import"
      pattern: "plugin-websocket"
---

<objective>
Build the WebSocket connection layer using Tauri's plugin-websocket and the chat state management hook. This creates the communication backbone that connects the desktop to the gateway.

Purpose: Without WebSocket connection and chat state, the app cannot send or receive messages. This is the core data flow layer.
Output: useWebSocket hook with auto-reconnect, useChat hook with message state and streaming accumulation, and typed message factories matching the gateway protocol.
</objective>

<execution_context>
@/Users/drew-mini/.claude/get-shit-done/workflows/execute-plan.md
@/Users/drew-mini/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-desktop-chat-app-rebuild/31-RESEARCH.md
@.planning/phases/31-desktop-chat-app-rebuild/31-01-SUMMARY.md
@packages/gateway/src/ws/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gateway client message factories and protocol types</name>
  <files>
    apps/desktop/src/lib/gateway-client.ts
  </files>
  <action>
    Create typed message factory functions that produce properly shaped client messages matching the gateway protocol. Do NOT import from @tek/gateway (Node.js package -- won't work in webview). Instead, define local types matching the gateway protocol.

    **Client message types to define (TypeScript interfaces):**
    - ChatSend: { type: 'chat.send', id: string, content: string, sessionId?: string, model?: string, agentId?: string }
    - SessionList: { type: 'session.list', id: string }
    - ToolApprovalResponse: { type: 'tool.approval.response', id: string, toolCallId: string, approved: boolean, sessionApprove?: boolean }
    - ThreadList: { type: 'thread.list', id: string, includeArchived?: boolean }

    **Server message types to define (discriminated union on 'type' field):**
    - ChatStreamStart: { type: 'chat.stream.start', requestId, sessionId, model, routing? }
    - ChatStreamDelta: { type: 'chat.stream.delta', requestId, delta }
    - ChatStreamEnd: { type: 'chat.stream.end', requestId, usage: { inputTokens, outputTokens, totalTokens }, cost: { inputCost, outputCost, totalCost } }
    - SessionCreated: { type: 'session.created', sessionId, sessionKey }
    - SessionListResponse: { type: 'session.list', requestId, sessions[] }
    - ToolCallNotify: { type: 'tool.call', requestId, toolCallId, toolName, args }
    - ToolResultNotify: { type: 'tool.result', requestId, toolCallId, toolName, result }
    - ToolErrorNotify: { type: 'tool.error', requestId, toolCallId, toolName, error }
    - ToolApprovalRequest: { type: 'tool.approval.request', requestId, toolCallId, toolName, args, risk? }
    - ErrorMessage: { type: 'error', requestId?, code, message }

    **Factory functions** (each generates a unique id using crypto.randomUUID()):
    - createChatSend(content, opts?: { sessionId?, model?, agentId? }): ChatSend
    - createSessionList(): SessionList
    - createToolApprovalResponse(toolCallId, approved, sessionApprove?): ToolApprovalResponse
    - createThreadList(includeArchived?): ThreadList

    **ChatMessage union type** for display state:
    ```typescript
    type ChatMessage =
      | { type: 'text'; id: string; role: 'user' | 'assistant' | 'system'; content: string; timestamp: number; model?: string }
      | { type: 'tool_call'; id: string; toolCallId: string; toolName: string; args: unknown; result?: unknown; error?: string; status: 'pending' | 'running' | 'completed' | 'error' }
      | { type: 'tool_approval'; id: string; toolCallId: string; toolName: string; args: unknown; risk?: string; status: 'pending' | 'approved' | 'denied' };
    ```

    Export ServerMessage as a union type of all server message interfaces (no Zod needed in frontend -- trust gateway validates).
  </action>
  <verify>
    - `grep "createChatSend" apps/desktop/src/lib/gateway-client.ts` matches
    - `grep "ChatMessage" apps/desktop/src/lib/gateway-client.ts` matches
    - `grep "ServerMessage" apps/desktop/src/lib/gateway-client.ts` matches
    - No imports from @tek/gateway or @tek/core in the file
  </verify>
  <done>
    Gateway client module defines all message types locally (no Node.js imports), provides factory functions for creating client messages with unique IDs, and exports a ChatMessage union type for display state.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create WebSocket hook and chat state management hook</name>
  <files>
    apps/desktop/src/hooks/useWebSocket.ts
    apps/desktop/src/hooks/useChat.ts
  </files>
  <action>
    1. **src/hooks/useWebSocket.ts**: Create useWebSocket hook using @tauri-apps/plugin-websocket:
       - Import WebSocket from '@tauri-apps/plugin-websocket'
       - Accept params: { url: string; onMessage: (data: string) => void; enabled?: boolean }
       - Manage connection state: 'disconnected' | 'connecting' | 'connected' | 'error'
       - **Connection lifecycle:**
         - When enabled and url changes, create new WebSocket connection
         - Register onOpen, onMessage, onClose handlers
         - On message received, call onMessage callback with raw string data
       - **Auto-reconnect with exponential backoff:**
         - On close/error: schedule reconnect after delay
         - Delays: 1s -> 2s -> 4s -> 8s -> 16s -> 30s (max)
         - Reset delay to 1s on successful connection
         - Track reconnect attempt count
       - **Cleanup:** Close WebSocket on unmount or when disabled
       - Return: { status, send: (data: string) => void, reconnect: () => void }
       - Use useRef for WebSocket instance and reconnect timer to avoid stale closures
       - Use useCallback for send function

    2. **src/hooks/useChat.ts**: Create useChat hook for chat state management:
       - Accept params: { port: number | null; agentId: string | null }
       - Internal state:
         - messages: ChatMessage[] (completed messages)
         - streamingText: string (accumulating delta text)
         - streamingRequestId: string | null (active stream request ID)
         - isStreaming: boolean
         - currentModel: string | null (from chat.stream.start)
         - usage: { inputTokens, outputTokens, totalTokens } | null
         - cost: { totalCost } | null
       - Construct WS URL: `ws://127.0.0.1:${port}/gateway` when port is available
       - Use useWebSocket with onMessage handler that parses JSON and dispatches:
         - chat.stream.start: set isStreaming=true, save sessionId to app store, save model
         - chat.stream.delta: append delta to streamingText
         - chat.stream.end: move streamingText to completed assistant message, clear streaming state, save usage/cost
         - session.created: update sessionId in app store
         - tool.call: append tool_call message to messages
         - tool.result: update matching tool_call message with result and status='completed'
         - tool.error: update matching tool_call message with error and status='error'
         - tool.approval.request: append tool_approval message to messages
         - error: append system message with error content
       - **sendMessage(content: string):**
         - Append user message to messages array
         - Get sessionId from app store
         - Send createChatSend(content, { sessionId, agentId }) via WebSocket
       - **approveToolCall(toolCallId: string, approved: boolean, sessionApprove?: boolean):**
         - Send createToolApprovalResponse via WebSocket
         - Update tool_approval message status to 'approved' or 'denied'
       - Return: { messages, streamingText, isStreaming, currentModel, usage, cost, sendMessage, approveToolCall, wsStatus }
  </action>
  <verify>
    - `grep "useWebSocket" apps/desktop/src/hooks/useWebSocket.ts` matches
    - `grep "useChat" apps/desktop/src/hooks/useChat.ts` matches
    - `grep "exponential\|backoff\|reconnect" apps/desktop/src/hooks/useWebSocket.ts` matches
    - `grep "chat.stream.delta" apps/desktop/src/hooks/useChat.ts` matches
    - `grep "sendMessage" apps/desktop/src/hooks/useChat.ts` matches
    - No imports from @tek/gateway or @tek/core
  </verify>
  <done>
    useWebSocket connects to gateway via Tauri plugin with auto-reconnect (exponential backoff 1s->30s). useChat manages full chat lifecycle: user messages, streaming delta accumulation, tool call tracking, tool approval flow, session management. Both hooks are ready for the ChatView to consume.
  </done>
</task>

</tasks>

<verification>
- gateway-client.ts defines local types matching gateway protocol (no @tek/gateway imports)
- useWebSocket uses @tauri-apps/plugin-websocket (not browser WebSocket)
- Auto-reconnect fires with increasing delays on connection loss
- useChat correctly dispatches all server message types to state updates
- Streaming text accumulates via delta concatenation and finalizes on stream.end
- Tool call lifecycle tracked: call -> approval request -> result/error
- sendMessage creates proper chat.send protocol message
</verification>

<success_criteria>
The data layer is complete: WebSocket connection with resilient reconnect, typed message protocol, and full chat state management. The ChatView (Plan 04) can consume these hooks directly to render the UI.
</success_criteria>

<output>
After completion, create `.planning/phases/31-desktop-chat-app-rebuild/31-03-SUMMARY.md`
</output>
