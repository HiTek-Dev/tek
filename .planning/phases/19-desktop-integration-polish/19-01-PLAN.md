---
phase: 19-desktop-integration-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/gateway/src/key-server/server.ts
  - apps/desktop/src/lib/discovery.ts
  - packages/cli/src/commands/gateway.ts
autonomous: true
requirements: []

must_haves:
  truths:
    - "`tek gateway stop` reliably terminates the gateway process and cleans up runtime.json"
    - "Desktop correctly detects stale runtime.json when gateway has crashed"
    - "Restarting gateway after stop does not fail with EADDRINUSE"
  artifacts:
    - path: "packages/gateway/src/key-server/server.ts"
      provides: "Graceful server.close() before process exit in SIGTERM/SIGINT handlers"
      contains: "server.close"
    - path: "apps/desktop/src/lib/discovery.ts"
      provides: "HTTP health check for PID liveness verification"
      contains: "fetch.*health"
  key_links:
    - from: "packages/cli/src/commands/gateway.ts"
      to: "packages/gateway/src/key-server/server.ts"
      via: "SIGTERM signal"
      pattern: "process\\.kill.*SIGTERM"
    - from: "apps/desktop/src/lib/discovery.ts"
      to: "packages/gateway/src/key-server/server.ts"
      via: "HTTP health endpoint"
      pattern: "fetch.*127\\.0\\.0\\.1.*health"
---

<objective>
Fix gateway stop command and stale gateway detection.

Purpose: `tek gateway stop` fails because the SIGTERM handler doesn't gracefully close Fastify, leaving sockets in TIME_WAIT. The desktop's `discoverGateway()` doesn't verify the process is actually alive, showing "running" for crashed gateways.

Output: Reliable gateway stop with graceful Fastify shutdown, and desktop health-check-based liveness detection.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/gateway/src/key-server/server.ts
@apps/desktop/src/lib/discovery.ts
@packages/cli/src/commands/gateway.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add graceful Fastify shutdown to SIGTERM/SIGINT handlers</name>
  <files>packages/gateway/src/key-server/server.ts</files>
  <action>
In `packages/gateway/src/key-server/server.ts`, refactor the SIGTERM and SIGINT handlers to call `server.close()` before cleanup and exit. The current handlers (lines 97-105) just call `cleanup()` (which does `unlinkSync(RUNTIME_PATH)`) then `process.exit(0)`.

Replace with an async shutdown function:
```typescript
const shutdown = async (signal: string) => {
  logger.info(`Received ${signal}, shutting down gracefully`);
  try {
    await server.close();
  } catch {
    // Server close may fail if already closed
  }
  cleanup();
  process.exit(0);
};

process.on("SIGTERM", () => { shutdown("SIGTERM"); });
process.on("SIGINT", () => { shutdown("SIGINT"); });
```

This ensures TCP connections are properly terminated before the process exits, preventing EADDRINUSE on restart.
  </action>
  <verify>Build the gateway package: `cd /Users/hitekmedia/Documents/GitHub/tek && npx tsc -p packages/gateway/tsconfig.json --noEmit` — should compile without errors.</verify>
  <done>SIGTERM/SIGINT handlers call server.close() before cleanup and exit. Gateway stop no longer leaves port in TIME_WAIT state.</done>
</task>

<task type="auto">
  <name>Task 2: Add HTTP health check to desktop gateway discovery</name>
  <files>apps/desktop/src/lib/discovery.ts</files>
  <action>
In `apps/desktop/src/lib/discovery.ts`, after reading runtime.json and parsing the data, add an HTTP health check to verify the gateway is actually reachable. The desktop can't use `process.kill(pid, 0)` (browser context), so use `fetch` to hit the gateway's `/health` endpoint.

After the existing `if (!data.pid || !data.port || !data.startedAt)` check, add:

```typescript
// Verify gateway is actually reachable (handles stale runtime.json from crashed gateway)
try {
  const controller = new AbortController();
  const timeout = setTimeout(() => controller.abort(), 2000);
  const res = await fetch(`http://127.0.0.1:${data.port}/health`, { signal: controller.signal });
  clearTimeout(timeout);
  if (!res.ok) return null;
} catch {
  return null; // Gateway not reachable, stale runtime.json
}
```

Use a 2-second timeout via AbortController to avoid hanging on unresponsive gateways.
  </action>
  <verify>Build the desktop frontend: `cd /Users/hitekmedia/Documents/GitHub/tek/apps/desktop && npx tsc --noEmit` — should compile without errors. Verify the fetch call has an AbortController timeout.</verify>
  <done>Desktop correctly returns null for stale runtime.json when the gateway process has crashed. Live gateways are detected via HTTP health check.</done>
</task>

</tasks>

<verification>
1. Build gateway package without errors
2. Build desktop app without errors
3. Verify server.ts SIGTERM handler includes `server.close()` call
4. Verify discovery.ts includes HTTP health check with timeout
</verification>

<success_criteria>
- Gateway SIGTERM handler calls `server.close()` before `cleanup()` and `process.exit(0)`
- Desktop `discoverGateway()` hits `/health` endpoint to verify gateway is alive
- Stale runtime.json (from crashed gateway) results in `null` return from `discoverGateway()`
- Both packages compile without type errors
</success_criteria>

<output>
After completion, create `.planning/phases/19-desktop-integration-polish/19-01-SUMMARY.md`
</output>
