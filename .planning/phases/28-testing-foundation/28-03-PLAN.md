---
phase: 28-testing-foundation
plan: 03
type: tdd
wave: 1
depends_on: []
files_modified:
  - packages/gateway/src/agent/tool-loop.test.ts
  - packages/gateway/src/context/assembler.test.ts
autonomous: true
requirements:
  - TEST-02
  - TEST-06

must_haves:
  truths:
    - "Agent loop sends streaming text deltas to the mock transport"
    - "Agent loop sends a completion message when the stream finishes"
    - "Context assembler builds a system prompt containing soul content"
    - "Context assembler builds a system prompt containing memory content"
    - "Context assembler builds a system prompt containing identity content"
    - "Context assembler returns structured sections array with correct names"
  artifacts:
    - path: "packages/gateway/src/agent/tool-loop.test.ts"
      provides: "Agent loop unit tests with mock transport and mock streamText"
      min_lines: 60
    - path: "packages/gateway/src/context/assembler.test.ts"
      provides: "Context assembly tests with mocked managers"
      min_lines: 50
  key_links:
    - from: "packages/gateway/src/agent/tool-loop.test.ts"
      to: "packages/gateway/src/agent/tool-loop.ts"
      via: "import runAgentLoop"
      pattern: "import.*tool-loop"
    - from: "packages/gateway/src/context/assembler.test.ts"
      to: "packages/gateway/src/context/assembler.ts"
      via: "import assembleContext"
      pattern: "import.*assembler"
---

<objective>
Write unit tests for the agent tool loop (with MockLanguageModelV3 and mock Transport) and context assembly (with mocked memory/thread managers, config, and skills).

Purpose: Cover the two most complex gateway subsystems that integrate multiple dependencies -- the streaming agent loop and the system prompt builder. These are the highest-risk areas for regressions.
Output: Two co-located test files with mock-based integration tests.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-testing-foundation/28-RESEARCH.md
@packages/gateway/src/agent/tool-loop.ts
@packages/gateway/src/context/assembler.ts
@packages/gateway/src/ws/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Agent loop unit tests with mock Transport and mock streamText</name>
  <files>packages/gateway/src/agent/tool-loop.test.ts</files>
  <action>
Create `tool-loop.test.ts` co-located beside `tool-loop.ts`.

**Read `tool-loop.ts` first** to understand: the function signature of `runAgentLoop`, what parameters it takes, what it does with the Transport (sends ServerMessages), and how it uses `streamText` from the AI SDK. Also read `packages/gateway/src/ws/connection.ts` to understand how `initConnection` works for creating test ConnectionState.

**Mock setup:**
1. Mock `../llm/registry.js` to return a mock registry whose `languageModel()` returns the `MockLanguageModelV3` instance.
2. Import `MockLanguageModelV3` from `ai/test` and `simulateReadableStream` from `ai`.
3. Create a `createMockTransport()` helper that returns `{ transportId: "test:1", channel: "ws" as const, send: vi.fn(), messages: [] }` where `send` pushes messages to the array.
4. Mock any other module dependencies `runAgentLoop` imports (check the file -- it may import config, approval-gate, connection state, etc.). Mock them all with `vi.mock()`.

**Test cases:**
1. **Text-only stream:** Configure `MockLanguageModelV3` with `doStream` returning a stream of text-delta chunks ending with a finish chunk. Call `runAgentLoop` with the mock transport and a simple user message. Verify the transport received messages including text content ("Hello world" or similar).
2. **Stream completion:** Verify the transport receives a completion/done message type when the stream finishes. Check the exact ServerMessage type by reading protocol.ts (likely `chat.delta` and `chat.complete` or similar).
3. **Empty stream:** Mock model returns only a finish chunk with no text. Verify the loop completes without error.
4. **Error handling:** If the mock model's `doStream` throws, verify the transport receives an error-type ServerMessage (not an unhandled exception).

**CRITICAL NOTES:**
- Read `tool-loop.ts` CAREFULLY to understand all imports and dependencies before writing mocks. Every imported module that has side effects or external calls must be mocked.
- Use `vi.hoisted()` for mock variables that need to be available before imports are resolved.
- Always include a `finish` chunk at the end of `simulateReadableStream` chunks to prevent hangs.
- Set `vi.setConfig({ testTimeout: 10000 })` to catch hanging tests during development.
- The exact chunk format for `MockLanguageModelV3` doStream in AI SDK v6 uses: `{ type: "text-start" }`, `{ type: "text-delta", delta: "..." }`, `{ type: "text-end" }`, `{ type: "finish", finishReason: { unified: "stop", raw: undefined }, ... }`. Refer to the research file Example 2.
- If tool-loop.ts is too heavily coupled to run with mocks (more than ~6 module mocks needed), simplify: test only the text streaming path, skip tool-call paths, and add a comment noting tool-call tests need source refactoring.
  </action>
  <verify>Run `pnpm vitest run packages/gateway/src/agent/tool-loop.test.ts` -- all tests pass within 10s timeout.</verify>
  <done>Agent loop sends text deltas and completion messages to mock transport. Stream lifecycle (start, deltas, finish) produces correct ServerMessage sequence. Error path sends error message.</done>
</task>

<task type="auto">
  <name>Task 2: Context assembly tests with mocked managers</name>
  <files>packages/gateway/src/context/assembler.test.ts</files>
  <action>
Create `assembler.test.ts` co-located beside `assembler.ts`.

**Read `assembler.ts` first** to understand: the function signature of `assembleContext`, what it returns (likely a system prompt string or structured object with sections), and all module-level imports it uses.

**Mock setup (use vi.mock for each):**
1. Mock `@tek/core` -- specifically `loadConfig` to return a minimal valid config.
2. Mock `@tek/db` -- if imported, return empty/stub implementations.
3. Mock `../memory/memory-manager.js` -- `getMemoryManager` returns `{ getMemoryContext: vi.fn().mockResolvedValue("Long-term memory: User prefers TypeScript") }` (or matching the actual interface).
4. Mock `../memory/thread-manager.js` -- `getThreadManager` returns `{ buildSystemPrompt: vi.fn().mockResolvedValue("Thread context here") }` (or matching actual interface).
5. Mock `../usage/pricing.js` -- `getModelPricing` returns a stub pricing object.
6. Mock `tokenx` or whatever token estimation module is used -- `estimateTokenCount` returns a fixed number.
7. Mock `../skills/discover.js` (if used) -- `discoverSkills` returns an empty array.

**Test cases:**
1. **System prompt includes soul content:** Call `assembleContext` with a soul document string. Verify the returned system prompt string contains the soul content.
2. **System prompt includes identity content:** Provide agent identity fields. Verify identity appears in the output.
3. **System prompt includes memory content:** Verify the mocked memory context string appears in the system prompt.
4. **Sections array structure:** If assembleContext returns sections (array of { name, content }), verify the section names include expected values (e.g., "soul", "identity", "memory", "style").
5. **Missing optional fields:** Call with minimal args (no soul, no memory). Verify it still returns a valid prompt without errors.

**CRITICAL NOTES:**
- Read `assembler.ts` CAREFULLY before writing any mocks. The actual function signature and return type determine what tests are possible.
- The mock burden is heavy (~6 modules). If a mock fails to resolve, use `vi.hoisted()` for mock variables and ensure import paths match exactly (including `.js` extensions).
- Focus on testing that sections are present and contain expected content, NOT exact string matching (brittle).
- Use `toContain()` or regex matchers for string assertions rather than `toBe()`.
  </action>
  <verify>Run `pnpm vitest run packages/gateway/src/context/assembler.test.ts` -- all tests pass.</verify>
  <done>assembleContext produces a system prompt containing soul, identity, and memory sections. Missing optional fields don't cause errors. Section structure matches expected names.</done>
</task>

</tasks>

<verification>
```bash
# Run both test files
pnpm vitest run packages/gateway/src/agent/tool-loop.test.ts packages/gateway/src/context/assembler.test.ts

# Full test suite from repo root
pnpm test
```
Both test files discovered and passing. Zero test failures. No hanging tests.
</verification>

<success_criteria>
- tool-loop.test.ts covers text streaming, completion, empty stream, and error paths with MockLanguageModelV3 and mock Transport
- assembler.test.ts covers system prompt construction with soul/memory/identity content through mocked managers
- `pnpm test` from repo root discovers and runs both files within reasonable timeout
</success_criteria>

<output>
After completion, create `.planning/phases/28-testing-foundation/28-03-SUMMARY.md`
</output>
