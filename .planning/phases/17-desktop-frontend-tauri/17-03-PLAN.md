---
phase: 17-desktop-frontend-tauri
plan: 03
type: execute
wave: 3
depends_on: ["17-01", "17-02"]
files_modified:
  - apps/desktop/src/lib/gateway-client.ts
  - apps/desktop/src/hooks/useWebSocket.ts
  - apps/desktop/src/hooks/useChat.ts
  - apps/desktop/src/pages/ChatPage.tsx
  - apps/desktop/src/components/ChatMessage.tsx
  - apps/desktop/src/components/ChatInput.tsx
  - apps/desktop/src/components/StreamingText.tsx
autonomous: true
requirements:
  - DESK-03

must_haves:
  truths:
    - "User can type a message and send it to the gateway via WebSocket"
    - "Assistant responses stream in real-time as tokens arrive"
    - "Conversation history is displayed with user and assistant messages distinguished"
    - "WebSocket connection auto-connects when gateway is discovered running"
  artifacts:
    - path: "apps/desktop/src/hooks/useWebSocket.ts"
      provides: "WebSocket connection hook using Tauri plugin"
    - path: "apps/desktop/src/hooks/useChat.ts"
      provides: "Chat state management with streaming support"
    - path: "apps/desktop/src/pages/ChatPage.tsx"
      provides: "Full chat interface page"
    - path: "apps/desktop/src/lib/gateway-client.ts"
      provides: "Typed message factory functions for gateway protocol"
  key_links:
    - from: "apps/desktop/src/hooks/useWebSocket.ts"
      to: "ws://127.0.0.1:PORT/gateway"
      via: "Tauri WebSocket plugin connect"
      pattern: "WebSocket\\.connect"
    - from: "apps/desktop/src/hooks/useChat.ts"
      to: "apps/desktop/src/hooks/useWebSocket.ts"
      via: "send function for outbound messages"
      pattern: "send.*chat\\.send"
    - from: "apps/desktop/src/lib/gateway-client.ts"
      to: "@tek/gateway protocol types"
      via: "Import ServerMessage/ClientMessage types"
      pattern: "import.*@tek/gateway"
---

<objective>
Build the chat interface with WebSocket connection to the gateway, real-time streaming display, and message history.

Purpose: The chat interface is the primary user interaction surface, replicating CLI chat capabilities in a GUI.
Output: ChatPage with working message input, streaming responses, and conversation history.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-desktop-frontend-tauri/17-RESEARCH.md
@.planning/phases/17-desktop-frontend-tauri/17-01-SUMMARY.md
@packages/cli/src/hooks/useWebSocket.ts
@packages/cli/src/hooks/useChat.ts
@packages/cli/src/lib/gateway-client.ts
@packages/gateway/src/ws/protocol.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: WebSocket hook and message client for Tauri</name>
  <files>
    apps/desktop/src/lib/gateway-client.ts
    apps/desktop/src/hooks/useWebSocket.ts
  </files>
  <action>
    **src/lib/gateway-client.ts:** Adapt from `packages/cli/src/lib/gateway-client.ts`. These are pure message factory functions -- copy and adapt.

    Export factory functions that create typed ClientMessage objects:
    - `createChatSendMessage(content: string, sessionId?: string, model?: string)` -- returns `{ type: 'chat.send', id: nanoid(), content, sessionId, model }`
    - `createSessionListMessage()` -- returns `{ type: 'session.list', id: nanoid() }`
    - `createContextInspectMessage(sessionId: string)` -- returns `{ type: 'context.inspect', id: nanoid(), sessionId }`
    - `createUsageQueryMessage(sessionId?: string)` -- returns `{ type: 'usage.query', id: nanoid(), sessionId }`

    Use `crypto.randomUUID()` instead of nanoid (avoid extra dependency). Import types from `@tek/gateway` if the package exports them, otherwise define minimal local types for the message shapes.

    **src/hooks/useWebSocket.ts:** Adapt from `packages/cli/src/hooks/useWebSocket.ts` but use Tauri WebSocket plugin.

    ```
    import TauriWebSocket from '@tauri-apps/plugin-websocket';
    ```

    Export `function useWebSocket(url: string | null)` that:
    1. Maintains state: `connected: boolean`, `error: string | null`
    2. Stores WebSocket instance in `useRef`
    3. On url change (non-null), connects via `TauriWebSocket.connect(url)`
    4. Sets up message listener that parses JSON and dispatches to registered callbacks
    5. Provides `send(msg: object)` function that JSON.stringifies and sends
    6. Provides `addMessageHandler(handler: (msg: any) => void)` and `removeMessageHandler`
    7. Cleans up on unmount: calls `ws.disconnect()`
    8. If url is null, does not connect (gateway not discovered)

    Handle reconnection: if connection drops, attempt reconnect after 3 seconds (max 5 retries).
  </action>
  <verify>
    - `cat apps/desktop/src/lib/gateway-client.ts` exports factory functions creating typed messages
    - `cat apps/desktop/src/hooks/useWebSocket.ts` uses TauriWebSocket.connect
    - No Node.js-specific imports (no `ws`, no `net`, no `http`)
  </verify>
  <done>WebSocket hook connects via Tauri plugin, message factories create typed protocol messages</done>
</task>

<task type="auto">
  <name>Task 2: Chat state hook and ChatPage UI components</name>
  <files>
    apps/desktop/src/hooks/useChat.ts
    apps/desktop/src/pages/ChatPage.tsx
    apps/desktop/src/components/ChatMessage.tsx
    apps/desktop/src/components/ChatInput.tsx
    apps/desktop/src/components/StreamingText.tsx
  </files>
  <action>
    **src/hooks/useChat.ts:** Adapt the chat state machine from `packages/cli/src/hooks/useChat.ts`.

    State: `messages: ChatMessage[]`, `streamingText: string`, `isStreaming: boolean`, `sessionId: string | null`, `model: string | null`, `error: string | null`.

    ChatMessage type (local, simple): `{ id: string; role: 'user' | 'assistant' | 'system'; content: string; timestamp: Date; model?: string; usage?: { inputTokens: number; outputTokens: number; cost: number } }`.

    The hook takes `send` function from useWebSocket. It:
    1. Registers a message handler on the WebSocket for server messages
    2. Handles `stream.start` -- sets isStreaming=true, records sessionId/model
    3. Handles `stream.delta` -- appends to streamingText
    4. Handles `stream.done` -- promotes streamingText to a new assistant message in messages array, clears streamingText, sets isStreaming=false, records usage
    5. Handles `stream.error` -- sets error, clears streaming state
    6. Provides `sendMessage(text: string)` that creates user message, adds to messages, and sends via WebSocket using createChatSendMessage
    7. Provides `clearMessages()` to reset conversation

    **src/components/ChatMessage.tsx:** Single message bubble component.

    Props: `{ message: ChatMessage }`. Renders:
    - User messages: right-aligned, blue-600 bg, white text, rounded-lg
    - Assistant messages: left-aligned, gray-800 bg, light text, rounded-lg
    - System messages: centered, yellow-600/10 bg, small text
    - Timestamp in small text below message
    - Model name badge if present
    - Token usage in small text if present (on assistant messages)

    **src/components/StreamingText.tsx:** Shows the currently-streaming assistant response.

    Props: `{ text: string; model?: string }`. Renders:
    - Left-aligned like assistant messages
    - Blinking cursor indicator at end of text
    - Model badge if provided
    - Subtle pulsing border to indicate active streaming

    **src/components/ChatInput.tsx:** Message input bar at bottom.

    Props: `{ onSend: (text: string) => void; disabled: boolean }`.
    - Text input (textarea) with auto-grow (max 6 lines)
    - Send button (arrow icon) on the right
    - Submit on Enter (Shift+Enter for newline)
    - Disabled state grays out input and hides send button

    **src/pages/ChatPage.tsx:** Replace stub with full chat interface.

    Layout (flex column, full height):
    - Header bar: "Chat" title, connection status indicator (green/red dot), session info
    - Message list (flex-grow, overflow-y-auto, scroll-to-bottom on new messages)
    - StreamingText component (shown when isStreaming)
    - ChatInput at bottom (disabled when not connected or isStreaming)

    Connect everything:
    1. Use discovery from lib/discovery.ts to get gateway port
    2. Construct WebSocket URL: `ws://127.0.0.1:${port}/gateway`
    3. Pass URL to useWebSocket (null if gateway not discovered)
    4. Pass send to useChat
    5. Render messages from useChat state

    Auto-scroll to bottom when new messages arrive or streamingText updates.
  </action>
  <verify>
    - `pnpm tauri dev`, navigate to Chat page
    - Type a message and press Enter -- message appears in chat as user message
    - If gateway is running, assistant response streams in
    - Connection status shows green when connected, red when disconnected
    - Messages scroll properly with overflow
  </verify>
  <done>Chat interface sends messages via WebSocket, displays streaming responses, shows conversation history with styled message bubbles</done>
</task>

</tasks>

<verification>
- WebSocket connects to gateway via Tauri plugin (not browser native WebSocket)
- Sending a message creates a chat.send protocol message with correct schema
- Streaming tokens appear progressively as they arrive from gateway
- Completed messages show in conversation history with role-based styling
- Auto-reconnect attempts when connection drops
- Chat input disables during streaming
</verification>

<success_criteria>
Users can type messages in the chat interface, see them sent to the gateway via WebSocket, and receive streaming assistant responses displayed in real-time with styled message bubbles. Connection state is visible and auto-reconnection works.
</success_criteria>

<output>
After completion, create `.planning/phases/17-desktop-frontend-tauri/17-03-SUMMARY.md`
</output>
