---
phase: 06-agent-capabilities
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - packages/gateway/src/llm/stream.ts
  - packages/gateway/src/llm/types.ts
  - packages/gateway/src/ws/protocol.ts
  - packages/gateway/src/ws/handlers.ts
  - packages/gateway/src/ws/server.ts
  - packages/gateway/src/ws/index.ts
  - packages/gateway/src/context/assembler.ts
  - packages/gateway/src/agent/tool-loop.ts
  - packages/gateway/src/agent/index.ts
autonomous: true

must_haves:
  truths:
    - "Streaming uses fullStream to capture tool-call and tool-result events alongside text deltas"
    - "Tool calls are relayed to the CLI via WebSocket protocol messages"
    - "Tool approval requests pause the agent loop until the client responds"
    - "Context assembler fills the skills and tools stub sections with real content"
    - "Agent loop supports multi-step tool calling with configurable step limit"
  artifacts:
    - path: "packages/gateway/src/llm/stream.ts"
      provides: "Tool-aware streaming via fullStream instead of textStream"
      contains: "fullStream"
    - path: "packages/gateway/src/ws/protocol.ts"
      provides: "tool.call, tool.result, tool.approval.request, tool.approval.response protocol messages"
      contains: "tool.call"
    - path: "packages/gateway/src/agent/tool-loop.ts"
      provides: "Agent tool loop with streamText, fullStream, and approval handling"
      exports: ["runAgentLoop"]
    - path: "packages/gateway/src/context/assembler.ts"
      provides: "Skills and tools sections populated from loaded skills and tool descriptions"
      contains: "formatSkillsForContext"
  key_links:
    - from: "packages/gateway/src/agent/tool-loop.ts"
      to: "packages/gateway/src/agent/tool-registry.ts"
      via: "buildToolRegistry provides tools for streamText"
      pattern: "buildToolRegistry"
    - from: "packages/gateway/src/ws/handlers.ts"
      to: "packages/gateway/src/agent/tool-loop.ts"
      via: "handleChatSend delegates to runAgentLoop for tool-enabled sessions"
      pattern: "runAgentLoop"
    - from: "packages/gateway/src/context/assembler.ts"
      to: "packages/core/src/skills/loader.ts"
      via: "discoverSkills + formatSkillsForContext"
      pattern: "formatSkillsForContext"
---

<objective>
Upgrade the streaming pipeline from text-only to tool-aware, add tool/approval WebSocket protocol messages, create the agent tool loop, and wire skills/tools into the context assembler.

Purpose: This is the core wiring plan that transforms the gateway from a text-streaming proxy into a tool-calling agent -- relaying tool events to the CLI, pausing for approval, and injecting skills context.
Output: Tool-aware streaming, agent loop, WS protocol extensions, filled context assembler stubs.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-agent-capabilities/06-RESEARCH.md
@.planning/phases/06-agent-capabilities/06-01-SUMMARY.md
@.planning/phases/06-agent-capabilities/06-02-SUMMARY.md

@packages/gateway/src/llm/stream.ts
@packages/gateway/src/llm/types.ts
@packages/gateway/src/ws/protocol.ts
@packages/gateway/src/ws/handlers.ts
@packages/gateway/src/ws/server.ts
@packages/gateway/src/context/assembler.ts
@packages/gateway/src/agent/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WS protocol messages and create agent tool loop</name>
  <files>
    packages/gateway/src/ws/protocol.ts
    packages/gateway/src/ws/index.ts
    packages/gateway/src/llm/types.ts
    packages/gateway/src/agent/tool-loop.ts
    packages/gateway/src/agent/index.ts
  </files>
  <action>
1. In `packages/gateway/src/ws/protocol.ts`, add new **client** message schemas:
   - `ToolApprovalResponseSchema`: z.object with `type: z.literal("tool.approval.response")`, `id: z.string()`, `toolCallId: z.string()`, `approved: z.boolean()`, `sessionApprove: z.boolean().optional()` (if true, auto-approve this tool for rest of session).
   - `PreflightApprovalSchema`: z.object with `type: z.literal("preflight.approval")`, `id: z.string()`, `requestId: z.string()`, `approved: z.boolean()`, `editedSteps: z.array(z.object({ description: z.string(), toolName: z.string().optional(), skip: z.boolean().optional() })).optional()`.
   - Add both to `ClientMessageSchema` discriminated union.
   - Export types: `ToolApprovalResponse`, `PreflightApproval`.

2. Add new **server** message schemas:
   - `ToolCallNotifySchema`: `type: z.literal("tool.call")`, `requestId`, `toolCallId`, `toolName`, `args: z.unknown()`.
   - `ToolResultNotifySchema`: `type: z.literal("tool.result")`, `requestId`, `toolCallId`, `toolName`, `result: z.unknown()`.
   - `ToolApprovalRequestSchema`: `type: z.literal("tool.approval.request")`, `requestId`, `toolCallId`, `toolName`, `args: z.unknown()`, `risk: z.enum(["low", "medium", "high"]).optional()`.
   - `PreflightChecklistSchema`: `type: z.literal("preflight.checklist")`, `requestId`, `steps: z.array(z.object({ description: z.string(), toolName: z.string().optional(), risk: z.enum(["low", "medium", "high"]), needsApproval: z.boolean() }))`, `estimatedCost: z.object({ inputTokens: z.number(), outputTokens: z.number(), estimatedUSD: z.number() })`, `requiredPermissions: z.array(z.string())`, `warnings: z.array(z.string())`.
   - Add all to `ServerMessageSchema` discriminated union.
   - Export types: `ToolCallNotify`, `ToolResultNotify`, `ToolApprovalRequest`, `PreflightChecklist`.

3. In `packages/gateway/src/llm/types.ts`, add tool-aware stream chunk types:
   - `StreamToolCall`: `{ type: "tool-call", toolCallId: string, toolName: string, args: unknown }`.
   - `StreamToolResult`: `{ type: "tool-result", toolCallId: string, toolName: string, result: unknown }`.
   - Update `StreamChunk` union to include the new types.

4. Create `packages/gateway/src/agent/tool-loop.ts`:
   - `runAgentLoop(options)` async function with options: `{ socket: WebSocket, model: string, messages: ModelMessage[], system: string, tools: Record<string, any>, requestId: string, sessionId: string, connState: ConnectionState, approvalPolicy: ApprovalPolicy, onUsage: (usage) => void }`.
   - Uses `streamText` from AI SDK with `{ model, messages, system, tools, stopWhen: stepCountIs(10) }`.
   - Iterates over `result.fullStream`:
     - `text-delta`: send `chat.stream.delta` via WS.
     - `tool-call`: send `tool.call` via WS. If tool needs approval (check via a helper that evaluates the policy), send `tool.approval.request` and await response via a Promise that resolves when the client sends `tool.approval.response` for this toolCallId. Store pending approvals in a Map<toolCallId, { resolve }> on the connection state.
     - `tool-result`: send `tool.result` via WS.
     - `finish-step`: log step boundary.
   - On approval timeout (60s default from config), auto-deny and continue.
   - After full stream completes, call `onUsage` with final usage.
   - Handle errors: send `error` message and clean up.

5. Re-export from `packages/gateway/src/agent/index.ts`.
  </action>
  <verify>
    `pnpm --filter @agentspace/gateway build` passes. Protocol types include tool.call, tool.result, tool.approval.request, tool.approval.response, preflight.checklist, preflight.approval. runAgentLoop is exported.
  </verify>
  <done>WebSocket protocol extended with 6 new message types for tools/approval/preflight. Agent tool loop uses fullStream to relay tool events and pause for approval.</done>
</task>

<task type="auto">
  <name>Task 2: Wire agent loop into handlers and fill context assembler stubs</name>
  <files>
    packages/gateway/src/ws/handlers.ts
    packages/gateway/src/ws/server.ts
    packages/gateway/src/ws/connection.ts
    packages/gateway/src/context/assembler.ts
    packages/gateway/src/llm/stream.ts
  </files>
  <action>
1. Update `packages/gateway/src/ws/connection.ts` to add to ConnectionState:
   - `pendingApprovals: Map<string, { resolve: (approved: boolean) => void }>` — for tool approval responses.
   - `tools: Record<string, any> | null` — cached tool registry for the connection.
   - `approvalPolicy: ApprovalPolicy | null` — per-connection approval policy.

2. Update `packages/gateway/src/ws/handlers.ts`:
   - Import `runAgentLoop` from agent module, `buildToolRegistry` from agent module, `MCPClientManager` from mcp module, `loadMCPConfigs` from mcp module, `createApprovalPolicy` from agent module, `loadConfig` from @agentspace/core.
   - Modify `handleChatSend`: after context assembly, if connection has no cached tools, call `buildToolRegistry` to create them (lazy init, cached on connState.tools). Then call `runAgentLoop` instead of `streamToClient` -- passing the tool registry, approval policy, and all required params.
   - Keep `streamToClient` as a fallback for when no tools are available (e.g., tool registry fails to build).
   - Add `handleToolApprovalResponse(socket, msg, connState)`: look up pending approval by toolCallId in connState.pendingApprovals, call resolve with msg.approved. If `msg.sessionApprove`, add tool to policy's sessionApprovals set.

3. Update `packages/gateway/src/ws/server.ts`:
   - Add dispatch case for `tool.approval.response` → `handleToolApprovalResponse`.
   - Add dispatch case for `preflight.approval` (stub for Plan 04).

4. Update `packages/gateway/src/context/assembler.ts`:
   - Import `discoverSkills`, `getSkillsDirs`, `formatSkillsForContext` from @agentspace/core.
   - Import `loadConfig` from @agentspace/core.
   - Replace the skills stub `addSection(sections, "skills", "", ...)` with:
     - Load config, get skills dirs, discover skills, format for context.
     - `addSection(sections, "skills", formatSkillsForContext(skills), ...)`.
   - Replace the tools stub `addSection(sections, "tools", "", ...)` with:
     - Accept an optional `toolDescriptions?: string` parameter on `assembleContext`.
     - `addSection(sections, "tools", toolDescriptions ?? "", ...)`.
   - This way the handler can pass tool descriptions string from the tool registry.

5. Update `packages/gateway/src/llm/stream.ts`:
   - Keep the existing `streamChatResponse` generator as-is for backward compatibility with non-tool streaming.
   - The new agent loop in tool-loop.ts calls `streamText` directly (not through this generator) because it needs `fullStream` access. No changes needed here beyond ensuring types are compatible.
   - Actually, do NOT modify stream.ts. The agent tool loop will call `streamText` directly. The existing `streamChatResponse` remains available for simple non-tool scenarios.
  </action>
  <verify>
    `pnpm --filter @agentspace/gateway build` passes. `handleChatSend` uses `runAgentLoop` when tools are available. Context assembler populates skills section from discovered SKILL.md files.
  </verify>
  <done>Agent loop wired into chat.send handler with tool registry and approval policy. Context assembler injects skills from SKILL.md files and tool descriptions from registry. Approval response handler resolves pending tool approvals.</done>
</task>

</tasks>

<verification>
- `pnpm build` succeeds across all packages
- `packages/gateway/src/ws/protocol.ts` contains tool.call, tool.result, tool.approval.request, tool.approval.response, preflight.checklist, preflight.approval
- `packages/gateway/src/agent/tool-loop.ts` exports runAgentLoop
- `packages/gateway/src/ws/handlers.ts` handleChatSend delegates to runAgentLoop
- `packages/gateway/src/context/assembler.ts` no longer has empty stub sections for skills
- ConnectionState has pendingApprovals map
</verification>

<success_criteria>
The gateway is now a tool-calling agent: chat.send triggers a multi-step agent loop that streams text, executes tool calls, relays results over WebSocket, and pauses for approval when needed. Skills are loaded from the filesystem and injected into every LLM call's context.
</success_criteria>

<output>
After completion, create `.planning/phases/06-agent-capabilities/06-03-SUMMARY.md`
</output>
