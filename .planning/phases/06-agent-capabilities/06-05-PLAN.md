---
phase: 06-agent-capabilities
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/gateway/src/ws/connection.ts
  - packages/gateway/src/agent/tool-loop.ts
  - packages/gateway/src/ws/handlers.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "When user presses S in the approval prompt, the tool is recorded as session-approved and subsequent calls to the same tool skip the approval prompt"
    - "pendingApprovals stores both toolName and resolve so the handler can look up the tool name by toolCallId"
  artifacts:
    - path: "packages/gateway/src/ws/connection.ts"
      provides: "PendingApproval type with toolName and resolve fields"
      contains: "toolName"
    - path: "packages/gateway/src/agent/tool-loop.ts"
      provides: "Stores toolName in pendingApprovals alongside resolve"
      contains: "toolName"
    - path: "packages/gateway/src/ws/handlers.ts"
      provides: "Calls recordSessionApproval when sessionApprove is true"
      contains: "recordSessionApproval"
  key_links:
    - from: "packages/gateway/src/agent/tool-loop.ts"
      to: "packages/gateway/src/ws/connection.ts"
      via: "pendingApprovals.set stores toolName"
      pattern: "pendingApprovals\\.set.*toolName"
    - from: "packages/gateway/src/ws/handlers.ts"
      to: "packages/gateway/src/agent/approval-gate.ts"
      via: "recordSessionApproval called on session approve"
      pattern: "recordSessionApproval\\(.*toolName"
---

<objective>
Fix session-approve (S key) so it actually records session approval in the policy.

Purpose: Close the one gap found in Phase 6 verification — session-approve is non-functional because `recordSessionApproval` is imported but never called, and the tool name is not available in the handler because `pendingApprovals` only stores the resolve function.

Output: Working session-approve flow where pressing S persists the approval in the policy and subsequent calls to the same tool skip the prompt.
</objective>

<execution_context>
@/Users/hitekmedia/.claude/get-shit-done/workflows/execute-plan.md
@/Users/hitekmedia/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-agent-capabilities/06-VERIFICATION.md
@packages/gateway/src/ws/connection.ts
@packages/gateway/src/agent/tool-loop.ts
@packages/gateway/src/ws/handlers.ts
@packages/gateway/src/agent/approval-gate.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Store toolName in pendingApprovals and call recordSessionApproval in handler</name>
  <files>
    packages/gateway/src/ws/connection.ts
    packages/gateway/src/agent/tool-loop.ts
    packages/gateway/src/ws/handlers.ts
  </files>
  <action>
Three changes across three files:

**1. `packages/gateway/src/ws/connection.ts`** — Update the `pendingApprovals` type to include `toolName`:

Change the `pendingApprovals` field in `ConnectionState` from:
```typescript
pendingApprovals: Map<string, { resolve: (approved: boolean) => void }>;
```
to:
```typescript
pendingApprovals: Map<string, { toolName: string; resolve: (approved: boolean) => void }>;
```

No other changes needed — the `new Map()` initializer in `initConnection` is untyped and will infer from the interface.

**2. `packages/gateway/src/agent/tool-loop.ts`** — In the `waitForApproval` function, accept a `toolName` parameter and store it alongside `resolve`:

- Add `toolName: string` as the second parameter to `waitForApproval` (between `toolCallId` and `connState`).
- In the `connState.pendingApprovals.set(toolCallId, { ... })` call, add `toolName` to the object: `{ toolName, resolve: ... }`.
- Update the call site in `runAgentLoop` (inside the `tool-approval-request` case) to pass `toolName` as the second argument: `waitForApproval(toolCallId, toolName, connState, APPROVAL_TIMEOUT_MS)`.

**3. `packages/gateway/src/ws/handlers.ts`** — In `handleToolApprovalResponse`, replace the comment-only session-approve block with an actual call to `recordSessionApproval`:

- Add import for `recordSessionApproval` from `"../agent/approval-gate.js"` (check if already imported — it is imported in tool-loop.ts but must also be imported in handlers.ts).
- Replace the block at ~line 721-727 (the `if (msg.sessionApprove && msg.approved && connState.approvalPolicy)` block) with:
```typescript
if (msg.sessionApprove && msg.approved && connState.approvalPolicy) {
    recordSessionApproval(pending.toolName, connState.approvalPolicy);
    logger.info(`Session-approved tool "${pending.toolName}" for toolCallId: ${msg.toolCallId}`);
}
```

Note: `pending` already holds `toolName` after the change to connection.ts, so `pending.toolName` is the correct reference.
  </action>
  <verify>
1. `npx tsc --noEmit` from `packages/gateway` — no type errors (the Map type change must be consistent across all usage sites).
2. Grep confirms `recordSessionApproval` is called in handlers.ts: `grep -n "recordSessionApproval" packages/gateway/src/ws/handlers.ts` should show an actual function call, not just a comment.
3. Grep confirms `toolName` is stored in pendingApprovals: `grep -n "toolName" packages/gateway/src/agent/tool-loop.ts` should show it in the `.set()` call.
4. Grep confirms the dead-code comment block ("Derive tool name from the pending state - not available directly") is removed from handlers.ts.
  </verify>
  <done>
- `pendingApprovals` Map stores `{ toolName, resolve }` (not just `{ resolve }`)
- `waitForApproval` accepts and forwards `toolName`
- `handleToolApprovalResponse` calls `recordSessionApproval(pending.toolName, connState.approvalPolicy)` when `msg.sessionApprove && msg.approved`
- TypeScript compiles without errors
- The dead import of `recordSessionApproval` in tool-loop.ts is no longer dead (it is used transitively through the stored toolName flowing to handlers.ts)
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd packages/gateway && npx tsc --noEmit` passes with zero errors
2. Static check: `grep -c "recordSessionApproval(" packages/gateway/src/ws/handlers.ts` returns at least 1 (function call, not just import)
3. Static check: `grep "toolName" packages/gateway/src/ws/connection.ts` confirms toolName in the PendingApproval type
4. Static check: `grep "toolName" packages/gateway/src/agent/tool-loop.ts` confirms toolName stored in pendingApprovals.set call
5. No regressions: the approve (Y) and deny (N) paths still work — `pending.resolve(msg.approved)` call is unchanged
</verification>

<success_criteria>
Session-approve gap from 06-VERIFICATION.md is closed: the `recordSessionApproval` function is called with the correct tool name when the client sends `sessionApprove: true`, and the tool name is available in the handler because `pendingApprovals` stores it alongside the resolve function. TypeScript compiles cleanly.
</success_criteria>

<output>
After completion, create `.planning/phases/06-agent-capabilities/06-05-SUMMARY.md`
</output>
